<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · UnROOT.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>UnROOT.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Introduction</a><ul class="internal"><li><a class="toctext" href="#Status-1">Status</a></li><li><a class="toctext" href="#Main-challenges-1">Main challenges</a></li><li><a class="toctext" href="#Low-hanging-fruits-1">Low hanging fruits</a></li><li><a class="toctext" href="#Acknowledgements-1">Acknowledgements</a></li></ul></li><li><a class="toctext" href="api/">API</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Introduction</a></li></ul><a class="edit-page" href="https://github.com/tamasgal/UnROOT.jl/blob/master/README.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Introduction</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="UnROOT.jl-1" href="#UnROOT.jl-1">UnROOT.jl</a></h1><p><a href="https://tamasgal.github.io/UnROOT.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt="Stable"/></a> <a href="https://tamasgal.github.io/UnROOT.jl/dev"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt="Dev"/></a> <a href="https://travis-ci.com/tamasgal/UnROOT.jl"><img src="https://travis-ci.com/tamasgal/UnROOT.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://codecov.io/gh/tamasgal/UnROOT.jl"><img src="https://codecov.io/gh/tamasgal/UnROOT.jl/branch/master/graph/badge.svg" alt="Codecov"/></a></p><p>UnROOT.jl is a (WIP) reader for the <a href="https://root.cern">CERN ROOT</a> file format written entirely in Julia, without depending on any official ROOT libraries. In contrast to the C++ ROOT framework, this packages focuses only on parsing of the files.</p><p>While the ROOT documentation does not contain a detailed description of the binary structure, the format can be triangulated by other packages like</p><ul><li><a href="https://github.com/scikit-hep/uproot">uproot</a> (Python)</li><li><a href="https://godoc.org/go-hep.org/x/hep/groot#hdr-File_layout">groot</a> (Go)</li><li><a href="https://github.com/cbourjau/alice-rs/tree/master/root-io">root-io</a> (Rust)</li><li><a href="https://github.com/spark-root/laurelin">Laurelin</a> (Java)</li><li><a href="https://github.com/root-project/root">ROOT</a> (Official C++ implementation)</li></ul><p>Here is also a short discussion about the <a href="https://github.com/scikit-hep/uproot/issues/401">ROOT binary format documentation</a> </p><h2><a class="nav-anchor" id="Status-1" href="#Status-1">Status</a></h2><p>The project is in early alpha prototyping phase and contributions are very welcome.</p><p>Reading of raw basket data is already working for uncompressed and Zlib-compressed files. The raw data consists of two vectors: the bytes and the offsets, which can be reinterpreted using a custom type.</p><p>Everything is in a very early alpha stage, as mentioned above.</p><p>Here is a quick demo of reading a simple branch containing a vector of integers using the preliminary high-level API, which works for non-jagged branches (simple vectors of primitive types):</p><pre><code class="language-julia">julia&gt; using UnROOT

julia&gt; f = ROOTFile(&quot;test/samples/tree_with_histos.root&quot;)
ROOTFile(&quot;test/samples/tree_with_histos.root&quot;) with 1 entry and 4 streamers.

julia&gt; array(f, &quot;t1/mynum&quot;)
25-element Array{Int32,1}:
  0
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 10
 10
 10
 10
 10
 10
 10
 10
 10
 10
 10
 10
 10
 10</code></pre><p>There is also a <code>raw</code> keyword which you can pass to <code>array()</code>, so it will skip the interpretation and return the raw bytes. This is similar to <code>uproot.asdebug</code> and can be used to read data where the streamers are not available (yet). Here is it in action, using some data from the KM3NeT experiment:</p><pre><code class="language-julia">julia&gt; using UnROOT

julia&gt; f = ROOTFile(&quot;test/samples/km3net_online.root&quot;)
ROOTFile(&quot;test/samples/km3net_online.root&quot;) with 10 entries and 41 streamers.

julia&gt; array(f, &quot;KM3NET_EVENT/KM3NET_EVENT/triggeredHits&quot;; raw=true)
2058-element Array{UInt8,1}:
 0x00
 0x03
 0x00
 0x01
 0x00
   ⋮
 0x56
 0x45
 0x4e
 0x54
 0x00</code></pre><p>This is what happens behind the scenes with some additional debug output:</p><pre><code class="language-julia">julia&gt; using UnROOT

julia&gt; f = ROOTFile(&quot;test/samples/tree_with_histos.root&quot;)
Compressed stream at 1509
ROOTFile(&quot;test/samples/tree_with_histos.root&quot;) with 1 entry and 4 streamers.

julia&gt; keys(f)
1-element Array{String,1}:
 &quot;t1&quot;

julia&gt; keys(f[&quot;t1&quot;])
Compressed datastream of 1317 bytes at 1509 (TKey &#39;t1&#39; (TTree))
2-element Array{String,1}:
 &quot;mynum&quot;
 &quot;myval&quot;

julia&gt; f[&quot;t1&quot;][&quot;mynum&quot;]
Compressed datastream of 1317 bytes at 6180 (TKey &#39;t1&#39; (TTree))
UnROOT.TBranch
  cursor: UnROOT.Cursor
  fName: String &quot;mynum&quot;
  fTitle: String &quot;mynum/I&quot;
  fFillColor: Int16 0
  fFillStyle: Int16 1001
  fCompress: Int32 101
  fBasketSize: Int32 32000
  fEntryOffsetLen: Int32 0
  fWriteBasket: Int32 1
  fEntryNumber: Int64 25
  fIOFeatures: UnROOT.ROOT_3a3a_TIOFeatures
  fOffset: Int32 0
  fMaxBaskets: UInt32 0x0000000a
  fSplitLevel: Int32 0
  fEntries: Int64 25
  fFirstEntry: Int64 0
  fTotBytes: Int64 170
  fZipBytes: Int64 116
  fBranches: UnROOT.TObjArray
  fLeaves: UnROOT.TObjArray
  fBaskets: UnROOT.TObjArray
  fBasketBytes: Array{Int32}((10,)) Int32[116, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  fBasketEntry: Array{Int64}((10,)) [0, 25, 0, 0, 0, 0, 0, 0, 0, 0]
  fBasketSeek: Array{Int64}((10,)) [238, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  fFileName: String &quot;&quot;


julia&gt; seek(f.fobj, 238)
IOStream(&lt;file test/samples/tree_with_histos.root&gt;)

julia&gt; basketkey = UnROOT.unpack(f.fobj, UnROOT.TKey)
UnROOT.TKey64(116, 1004, 100, 0x6526eafb, 70, 0, 238, 100, &quot;TBasket&quot;, &quot;mynum&quot;, &quot;t1&quot;)

julia&gt; s = UnROOT.datastream(f.fobj, basketkey)
Compressed datastream of 100 bytes at 289 (TKey &#39;mynum&#39; (TBasket))
IOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=100, maxsize=Inf, ptr=1, mark=-1)

julia&gt; [UnROOT.readtype(s, Int32) for _ in 1:f[&quot;t1&quot;][&quot;mynum&quot;].fEntries]
Compressed datastream of 1317 bytes at 6180 (TKey &#39;t1&#39; (TTree))
25-element Array{Int32,1}:
  0
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 10
 10
 10
 10
 10
 10
 10
 10
 10
 10
 10
 10
 10
 10</code></pre><h2><a class="nav-anchor" id="Main-challenges-1" href="#Main-challenges-1">Main challenges</a></h2><ul><li>ROOT data is generally stored as big endian and is a self-descriptive format, i.e. so-called streamers are stored in the files which describe the actual structure of the data in the corresponding branches. These streamers are read during runtime and need to be used to generate Julia structs and <code>unpack</code> methods on the fly.</li><li>Performance is very important for a low level I/O library.</li></ul><h2><a class="nav-anchor" id="Low-hanging-fruits-1" href="#Low-hanging-fruits-1">Low hanging fruits</a></h2><p>Pick one ;)</p><ul><li>[x] Parsing the file header</li><li>[x] Read the <code>TKey</code>s of the top level dictionary</li><li>[x] Reading the available trees</li><li>[ ] Reading the available streamers</li><li>[x] Reading a simple dataset with primitive streamers</li><li>[x] Reading of raw basket bytes for debugging</li><li>[ ] Automatically generate streamer logic</li></ul><h2><a class="nav-anchor" id="Acknowledgements-1" href="#Acknowledgements-1">Acknowledgements</a></h2><p>Special thanks to Jim Pivarski (<a href="https://github.com/jpivarski">@jpivarski</a>) from the <a href="https://github.com/scikit-hep">Scikit-HEP</a> project, who is the main author of <a href="https://github.com/scikit-hep/uproot">uproot</a>, a native Python library to read and write ROOT files, which was and is a great source of inspiration and information for reverse engineering the ROOT binary structures.</p><footer><hr/><a class="next" href="api/"><span class="direction">Next</span><span class="title">API</span></a></footer></article></body></html>
