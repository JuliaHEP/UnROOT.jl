var documenterSearchIndex = {"docs":
[{"location":"internalapis/#Commonly-used","page":"APIs","title":"Commonly used","text":"","category":"section"},{"location":"internalapis/","page":"APIs","title":"APIs","text":"Modules = [UnROOT]\nFilter   = t -> contains(string(t), \"Lazy\")","category":"page"},{"location":"internalapis/#UnROOT.LazyBranch","page":"APIs","title":"UnROOT.LazyBranch","text":"LazyBranch(f::ROOTFile, branch)\n\nConstruct an accessor for a given branch such that BA[idx] and or BA[1:20] is type-stable. And memory footprint is a single basket (<1MB usually). You can also iterate or map over it. If you want a concrete Vector, simply collect() the LazyBranch.\n\nExample\n\njulia> rf = ROOTFile(\"./test/samples/tree_with_large_array.root\");\n\njulia> b = rf[\"t1/int32_array\"];\n\njulia> ab = UnROOT.LazyBranch(rf, b);\n\njulia> for entry in ab\n           @show entry\n           break\n       end\nentry = 0\n\njulia> ab[begin:end]\n0\n1\n...\n\n\n\n\n\n","category":"type"},{"location":"internalapis/#UnROOT.LazyTree-Tuple{ROOTFile, AbstractString, Any}","page":"APIs","title":"UnROOT.LazyTree","text":"LazyTree(f::ROOTFile, s::AbstractString, branche::Union{AbstractString, Regex})\nLazyTree(f::ROOTFile, s::AbstractString, branches::Vector{Union{AbstractString, Regex}})\n\nConstructor for LazyTree, which is close to an DataFrame (interface wise), and a lazy Table (speed wise). Looping over a LazyTree is fast and type stable. Internally, LazyTree contains a typed table whose branch are LazyBranch. This means that at any given time only N baskets are cached, where N is the number of branches.\n\nnote: Note\nAccessing with [start:stop] will return a LazyTree with concrete internal table.\n\nwarning: Warning\nSplit branches are re-named, and the exact renaming may change. See  Issue 156 for context.\n\nExample\n\njulia> mytree = LazyTree(f, \"Events\", [\"Electron_dxy\", \"nMuon\", r\"Muon_(pt|eta)$\"])\n Row │ Electron_dxy     nMuon   Muon_eta         Muon_pt\n     │ Vector{Float32}  UInt32  Vector{Float32}  Vector{Float32}\n─────┼───────────────────────────────────────────────────────────\n 1   │ [0.000371]       0       []               []\n 2   │ [-0.00982]       2       [0.53, 0.229]    [19.9, 15.3]\n 3   │ []               0       []               []\n 4   │ [-0.00157]       0       []               []\n ⋮   │     ⋮            ⋮             ⋮                ⋮\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#More-Internal","page":"APIs","title":"More Internal","text":"","category":"section"},{"location":"internalapis/","page":"APIs","title":"APIs","text":"Modules = [UnROOT]\nFilter   = t -> !(contains(string(t), \"Lazy\"))","category":"page"},{"location":"internalapis/#UnROOT.HEAD_BUFFER_SIZE","page":"APIs","title":"UnROOT.HEAD_BUFFER_SIZE","text":"ROOTFile(filename::AbstractString; customstructs = Dict(\"TLorentzVector\" => LorentzVector{Float64}))\n\nROOTFile's constructor from a file. The customstructs dictionary can be used to pass user-defined struct as value and its corresponding fClassName (in Branch) as key such that UnROOT will know to intepret them, see interped_data.\n\nSee also: LazyTree, LazyBranch\n\nExample\n\njulia> f = ROOTFile(\"test/samples/NanoAODv5_sample.root\")\nROOTFile with 2 entries and 21 streamers.\ntest/samples/NanoAODv5_sample.root\n└─ Events\n   ├─ \"run\"\n   ├─ \"luminosityBlock\"\n   ├─ \"event\"\n   ├─ \"HTXS_Higgs_pt\"\n   ├─ \"HTXS_Higgs_y\"\n   └─ \"⋮\"\n\n\n\n\n\n","category":"constant"},{"location":"internalapis/#UnROOT.Cursor","page":"APIs","title":"UnROOT.Cursor","text":"The Cursor type is embeded into Branches of a TTree such that when we need to read the content of a Branch, we don't need to go through the Directory and find the TKey and then seek to where the Branch is.\n\nnote: Note\nThe io inside a Cursor is in fact only a buffer, it is NOT a io that refers to the whole file's stream.\n\n\n\n\n\n","category":"type"},{"location":"internalapis/#UnROOT.OffsetBuffer","page":"APIs","title":"UnROOT.OffsetBuffer","text":"OffsetBuffer\n\nWorks with seek, position of the original file. Think of it as a view of IOStream that can be indexed with original positions.\n\n\n\n\n\n","category":"type"},{"location":"internalapis/#UnROOT.Preamble-Union{Tuple{T}, Tuple{Any, Type{T}}} where T","page":"APIs","title":"UnROOT.Preamble","text":"Reads the preamble of an object.\n\nThe cursor will be put into the right place depending on the data.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.Streamers-Tuple{Any}","page":"APIs","title":"UnROOT.Streamers","text":"function Streamers(io)\n\nReads all the streamers from the ROOT source.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.array-Tuple{ROOTFile, AbstractString}","page":"APIs","title":"UnROOT.array","text":"array(f::ROOTFile, path; raw=false)\n\nReads an array from a branch. Set raw=true to return raw data and correct offsets.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.arrays-Tuple{ROOTFile, Any}","page":"APIs","title":"UnROOT.arrays","text":"arrays(f::ROOTFile, treename)\n\nReads all branches from a tree.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.auto_T_JaggT-Tuple{ROOTFile, Any}","page":"APIs","title":"UnROOT.auto_T_JaggT","text":"auto_T_JaggT(f::ROOTFile, branch; customstructs::Dict{String, Type})\n\nGiven a file and branch, automatically return (eltype, Jaggtype). This function is aware of custom structs that are carried with the parent ROOTFile.\n\nThis is also where you may want to \"redirect\" classname -> Julia struct name, for example \"TLorentzVector\" => LorentzVector here and you can focus on LorentzVectors.LorentzVector methods from here on.\n\nSee also: ROOTFile, interped_data\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.basketarray-Tuple{ROOTFile, AbstractString, Any}","page":"APIs","title":"UnROOT.basketarray","text":"basketarray(f::ROOTFile, path::AbstractString, ith)\nbasketarray(f::ROOTFile, branch::Union{TBranch, TBranchElement}, ith)\nbasketarray(lb::LazyBranch, ith)\n\nReads actual data from ith basket of a branch. This function first calls readbasket to obtain raw bytes and offsets of a basket, then calls auto_T_JaggT followed by interped_data to translate raw bytes into actual data.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.basketarray_iter-Tuple{ROOTFile, Any}","page":"APIs","title":"UnROOT.basketarray_iter","text":"basketarray_iter(f::ROOTFile, branch::Union{TBranch, TBranchElement})\nbasketarray_iter(lb::LazyBranch)\n\nReturns a Base.Generator yielding the output of basketarray() for all baskets.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.compressed_datastream-Tuple{Any, Any}","page":"APIs","title":"UnROOT.compressed_datastream","text":"compressed_datastream(io, tkey)\n\nExtract all [compressionheader][rawbytes] from a TKey. This is an isolated function because we want to compartmentalize disk I/O as much as possible.\n\nSee also: decompress_datastreambytes\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.decompress_datastreambytes-Tuple{Any, Any}","page":"APIs","title":"UnROOT.decompress_datastreambytes","text":"decompress_datastreambytes(compbytes, tkey)\n\nProcess the compressed bytes compbytes which was read out by compressed_datastream and pointed to from tkey. This function simply return uncompressed bytes according to the compression algorithm detected (or the lack of).\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.endcheck-Union{Tuple{T}, Tuple{Any, T}} where T<:UnROOT.Preamble","page":"APIs","title":"UnROOT.endcheck","text":"function endcheck(io, preamble::Preamble)\n\nChecks if everything went well after parsing a TOBject. Used in conjuction with Preamble.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.interped_data-Tuple{Any, Any, Type{Bool}, Type{UnROOT.Nojagg}}","page":"APIs","title":"UnROOT.interped_data","text":"interped_data(rawdata, rawoffsets, ::Type{T}, ::Type{J}) where {T, J<:JaggType}\n\nThe function thats interpret raw bytes (from a basket) into corresponding Julia data, based on type T and jagg type J.\n\nIn order to retrieve data from custom branches, user should defined more speialized method of this function with specific T and J. See TLorentzVector example.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.interped_data-Tuple{Any, Any, Type{Vector{LorentzVectors.LorentzVector{Float64}}}, Type{UnROOT.Offsetjagg}}","page":"APIs","title":"UnROOT.interped_data","text":"interped_data(rawdata, rawoffsets, ::Type{Vector{LorentzVector{Float64}}}, ::Type{Offsetjagg})\n\nThe interped_data method specialized for LorentzVector. This method will get called by basketarray instead of the default method for TLorentzVector branch.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.parseTH-Tuple{Dict{Symbol, Any}}","page":"APIs","title":"UnROOT.parseTH","text":"parseTH(th::Dict{Symbol, Any})\n\nParse the output of TH into a tuple of counts, edges, and sumw2. A StatsBase.Histogram can then be constructed with Histogram(edges, counts). TH1 and TH2 inputs are supported.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.readbasket-Tuple{ROOTFile, Any, Any}","page":"APIs","title":"UnROOT.readbasket","text":"readbasket(f::ROOTFile, branch, ith)\nreadbasketseek(f::ROOTFile, branch::Union{TBranch, TBranchElement}, seek_pos::Int, nbytes)\n\nThe fundamental building block of reading read data from a .root file. Read read one basket's raw bytes and offsets at a time. These raw bytes and offsets then (potentially) get processed by interped_data.\n\nSee also: auto_T_JaggT, basketarray\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.readobjany!-Tuple{Any, Union{UnROOT.TKey32, UnROOT.TKey64}, Any}","page":"APIs","title":"UnROOT.readobjany!","text":"function readobjany!(io, tkey::TKey, refs)\n\nThe main entrypoint where streamers are parsed and cached for later use. The refs dictionary holds the streamers or parsed data which are reused when already available.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.skiptobj-Tuple{Any}","page":"APIs","title":"UnROOT.skiptobj","text":"function skiptobj(io)\n\nSkips a TOBject.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.splitup-Tuple{Vector{UInt8}, Any, Type}","page":"APIs","title":"UnROOT.splitup","text":"splitup(data::Vector{UInt8}, offsets, T::Type; skipbytes=0)\n\nGiven the offsets and data return by array(...; raw = true), reconstructed the actual array (with custome struct, can be jagged as well).\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.topological_sort-Tuple{Any}","page":"APIs","title":"UnROOT.topological_sort","text":"function topological_sort(streamer_infos)\n\nSort the streamers with respect to their dependencies and keep only those which are not defined already.\n\nThe implementation is based on https://stackoverflow.com/a/11564769/1623645\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.unpack-Tuple{UnROOT.CompressionHeader}","page":"APIs","title":"UnROOT.unpack","text":"unpack(x::CompressionHeader)\n\nReturn the following information:\n\nName of compression algorithm\nLevel of the compression\ncompressedbytes and uncompressedbytes according to uproot3\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.@stack-Tuple{Any, Vararg{Any}}","page":"APIs","title":"UnROOT.@stack","text":"macro stack(into, structs...)\n\nStack the fields of multiple structs and create a new one. The first argument is the name of the new struct followed by the ones to be stacked. Parametric types are not supported and the fieldnames needs to be unique.\n\nExample:\n\n@stack Baz Foo Bar\n\nCreates Baz with the concatenated fields of Foo and Bar\n\n\n\n\n\n","category":"macro"},{"location":"advanced/custom_branch/#Parse-Custom-Branch","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"","category":"section"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"It is possible to parse Branches with custom structure as long as you know how the bytes should be interpreted. As an example, the TLorentzVector is added using this mechanism and we will walk through the steps needed:","category":"page"},{"location":"advanced/custom_branch/#.-Provide-a-map-between-fClassName-of-your-struct-(as-seen-in-.root)-to-a-Julia-type.","page":"Parse Custom Branch","title":"1. Provide a map between fClassName of your struct (as seen in .root) to a Julia type.","text":"","category":"section"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"Pass a Dict{String, Type} to ROOTFile(filepath; customstructs). The TLorentzVector is shipped by default:","category":"page"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"ROOTFile(filepath; customstructs = Dict(\"TLorentzVector\" => LorentzVector{Float64}))","category":"page"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"This Dict will subsequently be used by the auto_T_JaggT function at here such that when we encounter a branch with this fClassName, we will return your Type as the detected element type of this branch.","category":"page"},{"location":"advanced/custom_branch/#.-Extend-the-raw-bytes-interpreting-function-UnROOT.interped_data","page":"Parse Custom Branch","title":"2. Extend the raw bytes interpreting function UnROOT.interped_data","text":"","category":"section"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"By default, given a branch element type and a \"jaggness\" type, a general function is defined which will try to parse the raw bytes into Julia data structure. The ::Type{T} will match what you have provided in the Dict in the previous step.","category":"page"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"Thus, to \"teach\" UnROOT how to interpret bytes for your type T, you would want to defined a more specific UnROOT.interped_data than the default one. Taking the TLorentzVector as example again, we define a function:","category":"page"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"using LorentzVector\nconst LVF64 = LorentzVector{Float64}\nfunction UnROOT.interped_data(rawdata, rawoffsets, ::Type{LVF64}, ::Type{J}) where {T, J <: JaggType}\n    # `rawoffsets` is actually redundant, since we know each TLV is always 64 bytes (withe 32 bytes header)\n    [\n     reinterpret(LVF64, x) for x in Base.Iterators.partition(rawdata, 64)\n    ]\nend\n\nfunction Base.reinterpret(::Type{LVF64}, v::AbstractVector{UInt8}) where T\n    # x,y,z,t in ROOT\n    v4 = ntoh.(reinterpret(Float64, v[1+32:end]))\n    # t,x,y,z in LorentzVectors.jl\n    LVF64(v4[4], v4[1], v4[2], v4[3])\nend","category":"page"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"The Base.reinterpret function is just a helper function, you could instead write everything inside UnROOT.interped_data. We then builds on these, to interpret Jagged TLV branch: https://github.com/JuliaHEP/UnROOT.jl/blob/4747f6f5fd97ed1a872765485b4eb9e99ec5a650/src/custom.jl#L47","category":"page"},{"location":"advanced/custom_branch/#More-details","page":"Parse Custom Branch","title":"More details","text":"","category":"section"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"To expand a bit what we're doing here, the rawdata for a single TLV is always 64 bytes long and the first 32 bytes are TObject header which we don't care (which is why we don't care about rawoffsets here). The last 32 bytes make up 4 Float64 and we simply parse them and return a collection of (julia) LorentzVector{Float64}.","category":"page"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"In general, if auto_T_JaggT returned MyType as promised branch element type, then","category":"page"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"UnROOT.interped_data(rawdata, rawoffsets, ::Type{MyType},","category":"page"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"should return Vector{MyType} because UnROOT.interped_data receives raw bytes of a basket at a time.","category":"page"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"And that's it! Afterwards both LazyBranch and LazyTree will be able to constructed with correct type and also knows how to interpret bytes when you indexing or iterating through them","category":"page"},{"location":"advanced/custom_branch/#Reading-Raw-Data-from-Branch","page":"Parse Custom Branch","title":"Reading Raw Data from Branch","text":"","category":"section"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"Alternatively, reading raw data is also possible using the UnROOT.array(f::ROOTFile, path; raw=true) method. The output can be then reinterpreted using a custom type with the method UnROOT.splitup(data, offsets, T::Type; skipbytes=0, jagged=true). This provides more fine grain control in case your branch is highly irregular. You can then define suitable Julia type and readtype method for parsing these data. Alternatively, you can of course parse the data and offsets entirely manually. Here is it in action, with the help of the types from custom.jl, and some data from the KM3NeT experiment:","category":"page"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"julia> using UnROOT\n\njulia> f = ROOTFile(\"test/samples/km3net_online.root\")\nROOTFile(\"test/samples/km3net_online.root\") with 10 entries and 41 streamers.\n\njulia> data, offsets = array(f, \"KM3NET_EVENT/KM3NET_EVENT/snapshotHits\"; raw=true)\n2058-element Array{UInt8,1}:\n 0x00\n 0x03\n   ⋮\n   \njulia> UnROOT.splitup(data, offsets, UnROOT._KM3NETDAQHit)\n4-element Vector{Vector{UnROOT._KM3NETDAQHit}}:\n [UnROOT._KM3NETDAQHit(1073742790, 0x00, 9, 0x60)......","category":"page"},{"location":"performancetips/#Don't-\"double-access\"","page":"Performance Tips","title":"Don't \"double access\"","text":"","category":"section"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"Inside an event-loop:","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"for evt in mytree\n    evt.nMuon!=4 && continue\n    calculation(evt.nMuon)\nend","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"This is bad practice. Since evt is a lazy construct, read happens when you access a property by e.g. evt.nMuon. This means that if you need a branch multiple times, you should allocate a variable first:","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"for evt in mytree\n    nmu = evt.nMuon\n    nmu !=4 && continue\n    calculation(nmu)\nend","category":"page"},{"location":"exampleusage/#Chunk-Iteration","page":"Example Usage","title":"Chunk Iteration","text":"","category":"section"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"t = LazyTree(...)\nres = 0.0\nfor rang in Iterators.partition(1:lastindex(t), 10^6)\n    res += sum(t[rang].nMuon) #\nend\nres","category":"page"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"Note, t[rang] is eager, if you don't need all branches, it's much better to use t.nMuon[rang], or limit which branches are selected during LazyTree() creation time.","category":"page"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"This pattern works the best over network, for local files, stick with:","category":"page"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"for evt in t\n    ...\nend","category":"page"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"usually is the best approach.","category":"page"},{"location":"exampleusage/#Writting-out-.root-files","page":"Example Usage","title":"Writting out .root files","text":"","category":"section"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"Currently UnROOT.jl is focused on reading only, however, it's semi-trivial to leverage Python world for write operation since it's not performance critical.","category":"page"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"You have the following choice:","category":"page"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"PythonCall.jl – we will demo how to use this one\nPyCall.jl","category":"page"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"Checkout configuration docs for PythonCall.jl","category":"page"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"Most importantly, you probably want to set:","category":"page"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"ENV[\"JULIA_PYTHONCALL_EXE\"] = readchomp(`which python`)","category":"page"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"before the using PythonCall line. Especially if you're using LCG or Athena or CMSSW environment.","category":"page"},{"location":"exampleusage/#Write-out-a-TTree","page":"Example Usage","title":"Write out a TTree","text":"","category":"section"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"julia> using PythonCall\n\njulia> const up = pyimport(\"uproot\")\n\njulia> pywith(up.recreate(\"./example.root\")) do file\n           file[\"mytree\"] = Dict(\"branch1\"=>1:1000, \"branch2\"=>rand(1000))\n       end\n\n# read it back with UnROOT.jl\njulia> using UnROOT\n\njulia> LazyTree(\"./example.root\", \"mytree\")\n Row │ branch1  branch2              \n     │ Int64    Float64              \n─────┼───────────────────────────────\n 1   │ 1        0.5775868298287866\n 2   │ 2        0.7245212475492369\n 3   │ 3        0.009249240901789912\n 4   │ 4        0.9010206670973542\n 5   │ 5        0.7609879879740359\n 6   │ 6        0.00916447384387542\n 7   │ 7        0.5636229077934333\n 8   │ 8        0.32617388561103156\n  ⋮  │    ⋮              ⋮","category":"page"},{"location":"exampleusage/#Write-out-a-histogram","page":"Example Usage","title":"Write out a histogram","text":"","category":"section"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"A histogram is just a tuple of (bincontent, binedges), see  FHist.jl docs for details.","category":"page"},{"location":"advanced/reduce_latency/#Bake-sysimage-with-PackageCompiler.jl","page":"Reduce startup latency","title":"Bake sysimage with PackageCompiler.jl","text":"","category":"section"},{"location":"advanced/reduce_latency/","page":"Reduce startup latency","title":"Reduce startup latency","text":"You can bake a sysimage tailored for your analysis to reduce latency.","category":"page"},{"location":"advanced/reduce_latency/","page":"Reduce startup latency","title":"Reduce startup latency","text":"> cat readtree.jl\nusing UnROOT\n\nconst r = ROOTFile(\"/home/akako/.julia/dev/UnROOT/test/samples/NanoAODv5_sample.root\")\n\nconst t = LazyTree(r, \"Events\", [\"nMuon\", \"Electron_dxy\"])\n\n\n@show t[1, :Electron_dxy]\n\n> time julia --startup-file=no readtree.jl\nt[1, :Electron_dxy] = Float32[0.00037050247]\n\n________________________________________________________\nExecuted in   10.82 secs    fish           external\n   usr time   11.09 secs  580.00 micros   11.09 secs\n   sys time    0.65 secs  189.00 micros    0.65 secs","category":"page"},{"location":"advanced/reduce_latency/","page":"Reduce startup latency","title":"Reduce startup latency","text":"In Julia, `]add PackageCompiler':","category":"page"},{"location":"advanced/reduce_latency/","page":"Reduce startup latency","title":"Reduce startup latency","text":"julia> using PackageCompiler\n\njulia> PackageCompiler.create_sysimage(:UnROOT; precompile_statements_file=\"./readtree.jl\", sysimage_path=\"./unroot.so\", replace_default=false)'","category":"page"},{"location":"advanced/reduce_latency/","page":"Reduce startup latency","title":"Reduce startup latency","text":"profit:","category":"page"},{"location":"advanced/reduce_latency/","page":"Reduce startup latency","title":"Reduce startup latency","text":"> time julia -J ./unroot.so readtree.jl \nt[1, :Electron_dxy] = Float32[0.00037050247]\n\n________________________________________________________\nExecuted in  619.20 millis    fish           external\n   usr time  902.29 millis    0.00 millis  902.29 millis\n   sys time  658.59 millis    1.05 millis  657.54 millis","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Apart from the pursue of performance, we also strive to provide intuitive and compostable interface. After all, \"theoretically\" fast doesn't mean the performance is accessible for the first-time physics user.","category":"page"},{"location":"#Status","page":"Introduction","title":"Status","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"We support reading all scalar and jagged branches of \"basic\" types, provide indexing and iteration interface with a \"per branch\" basket-cache. There is a low level API to provide interpretation functionalities for custom types and classes. As a metric, UnROOT can read all branches (~1800) of CMS NanoAOD including jagged TLorentzVector branch.","category":"page"},{"location":"#Loops-aren't-slow","page":"Introduction","title":"Loops aren't slow","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"One good thing about Julia is you can always fallback to writing loops since they are not intrinsically slower (than C/C++), certainly much faster than Python. Continuing the example from README:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using UnROOT\n\njulia> f = ROOTFile(\"test/samples/NanoAODv5_sample.root\")\n\njulia> mytree = LazyTree(f, \"Events\", [\"Electron_dxy\", \"nMuon\", r\"Muon_(pt|eta)$\"])","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"There are essentially two loops you can use:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> for event in mytree\n           ...\n       end\n\njulia> for (i, event) in enumerate(mytree)\n           # i will be index of `mytree`: 1, 2, 3...\n           ...\n       end","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Both of which are compostable with @threads for multi-threading:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> Threads.@threads for event in mytree\n           ...\n       end\n\njulia> Threads.@threads for (i, event) in enumerate(mytree)\n           ...\n       end","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Only one basket per branch will be cached so you don't have to worry about running out of RAM. At the same time, event inside the for-loop is not materialized until a field is accessed.","category":"page"},{"location":"#Laziness-in-Indexing,-Slicing,-and-Looping","page":"Introduction","title":"Laziness in Indexing, Slicing, and Looping","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Laziness (or eagerness) in UnROOT generally refers to if an \"event\" has read each branches of the tree or not. As canonical example of eager event, consider indexing:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> const r = LazyTree(ROOTFile(\"./Run2012BC_DoubleMuParked_Muons.root\"), \"Events\", [\"nMuon\", \"Muon_phi\"]);\n\njulia> names(r)\n2-element Vector{String}:\n \"Muon_phi\"\n \"nMuon\"\n\njulia> r[1]\n(Muon_phi = Float32[-0.034272723, 2.5426154], nMuon = 0x00000002)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Where the iterate() over tree is lazy:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> const r = LazyTree(ROOTFile(\"./Run2012BC_DoubleMuParked_Muons.root\"), \"Events\", [\"nMuon\", \"Muon_phi\"]);\n\njulia> for (i, evt) in enumerate(r)\n           @show i, evt\n           break\n       end\n(i, evt) = (1, \"LazyEvent with: (:tree, :idx)\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"And the reading of actual data is delayed until evt.nMuon or evt.Muon_phi happens. Which means you should be careful about: Don't-\"double-access\".","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The laziness of the main interfaces are summarized below:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":" mytree enumerate(mytree)\nfor X in ... 💤 💤\n@threads for X in ... 💤 💤\ngetindex(tree, row::Int) 💤 N/A\ngetindex(tree, row::Range) 🚨 N/A","category":"page"},{"location":"devdocs/#Related-Projects","page":"For Contributors","title":"Related Projects","text":"","category":"section"},{"location":"devdocs/","page":"For Contributors","title":"For Contributors","text":"While the ROOT documentation does not contain a detailed description of the binary structure, the format can be triangulated by other packages like","category":"page"},{"location":"devdocs/","page":"For Contributors","title":"For Contributors","text":"uproot3 (Python), see also UpROOT.jl\ngroot (Go)\nroot-io (Rust)\nLaurelin (Java)","category":"page"},{"location":"devdocs/","page":"For Contributors","title":"For Contributors","text":"Here's a detailed from-scratch walk through  on reading a jagged branch from a ROOT file, recommended for first time contributors or those who just want to learn about ROOT file format.","category":"page"},{"location":"devdocs/","page":"For Contributors","title":"For Contributors","text":"Three's also a discussion reagarding the ROOT binary format documentation on uproot's issue page.","category":"page"}]
}
