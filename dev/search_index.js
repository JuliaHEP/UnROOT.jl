var documenterSearchIndex = {"docs":
[{"location":"api/#UnROOT.jl-1","page":"API","title":"UnROOT.jl","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Yep.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Modules = [UnROOT]","category":"page"},{"location":"api/#UnROOT.array-Tuple{ROOTFile,Any}","page":"API","title":"UnROOT.array","text":"function array(f::ROOTFile, path)\n\nReads an array from a branch. Currently hardcoded to Int32\n\n\n\n\n\n","category":"method"},{"location":"api/#DataFrames.DataFrame-Tuple{ROOTFile,Any}","page":"API","title":"DataFrames.DataFrame","text":"function DataFrame(f::ROOTFile, path)\n\nReads a tree into a dataframe\n\n\n\n\n\n","category":"method"},{"location":"api/#UnROOT.Preamble-Union{Tuple{T}, Tuple{Any,Type{T}}} where T","page":"API","title":"UnROOT.Preamble","text":"Reads the preamble of an object.\n\nThe cursor will be put into the right place depending on the data.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnROOT.Streamers-Tuple{Any}","page":"API","title":"UnROOT.Streamers","text":"function Streamers(io)\n\nReads all the streamers from the ROOT source.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnROOT.endcheck-Union{Tuple{T}, Tuple{Any,T}} where T<:UnROOT.Preamble","page":"API","title":"UnROOT.endcheck","text":"function endcheck(io, preamble::Preamble)\n\nChecks if everything went well after parsing a TOBject. Used in conjuction with Preamble.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnROOT.packedsizeof-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"API","title":"UnROOT.packedsizeof","text":"The packed size of a type, e.g. when stored on disk.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnROOT.readbytes!-NTuple{4,Any}","page":"API","title":"UnROOT.readbytes!","text":"function readbytes!(io, b, offset, nr)\n\nEfficient read of bytes into an existing array at a given offset\n\n\n\n\n\n","category":"method"},{"location":"api/#UnROOT.readobjany!-Tuple{Any,Union{UnROOT.TKey32, UnROOT.TKey64},Any}","page":"API","title":"UnROOT.readobjany!","text":"function readobjany!(io, tkey::TKey, refs)\n\nThe main entrypoint where streamers are parsed and cached for later use. The refs dictionary holds the streamers or parsed data which are reused when already available.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnROOT.skiptobj-Tuple{Any}","page":"API","title":"UnROOT.skiptobj","text":"function skiptobj(io)\n\nSkips a TOBject.\n\n\n\n\n\n","category":"method"},{"location":"api/#UnROOT.topological_sort-Tuple{Any}","page":"API","title":"UnROOT.topological_sort","text":"function topological_sort(streamer_infos)\n\nSort the streamers with respect to their dependencies and keep only those which are not defined already.\n\nThe implementation is based on https://stackoverflow.com/a/11564769/1623645\n\n\n\n\n\n","category":"method"},{"location":"api/#UnROOT.@stack-Tuple{Any,Vararg{Any,N} where N}","page":"API","title":"UnROOT.@stack","text":"macro stack(into, structs...)\n\nStack the fields of multiple structs and create a new one. The first argument is the name of the new struct followed by the ones to be stacked. Parametric types are not supported and the fieldnames needs to be unique.\n\nExample:\n\n@stack Baz Foo Bar\n\nCreates Baz with the concatenated fields of Foo and Bar\n\n\n\n\n\n","category":"macro"},{"location":"#UnROOT.jl-1","page":"Introduction","title":"UnROOT.jl","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Codecov)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"UnROOT.jl is a (WIP) reader for the CERN ROOT file format written entirely in Julia, without depending on any official ROOT libraries. In contrast to the C++ ROOT framework, this packages focuses only on parsing of the files.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"While the ROOT documentation does not contain a detailed description of the binary structure, the format can be triangulated by other packages like","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"uproot (Python)\ngroot (Go)\nroot-io (Rust)\nLaurelin (Java)\nROOT (Official C++ implementation)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Here is also a short discussion about the ROOT binary format documentation ","category":"page"},{"location":"#Status-1","page":"Introduction","title":"Status","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The project is in early alpha prototyping phase and contributions are very welcome.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Reading of raw basket data is already working for uncompressed and Zlib-compressed files. The raw data consists of two vectors: the bytes and the offsets, which can be reinterpreted using a custom type.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Everything is in a very early alpha stage, as mentioned above.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Here is a quick demo of reading a simple branch containing a vector of integers using the preliminary high-level API, which works for non-jagged branches (simple vectors of primitive types):","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"julia> using UnROOT\n\njulia> f = ROOTFile(\"test/samples/tree_with_histos.root\")\nROOTFile(\"test/samples/tree_with_histos.root\") with 1 entry and 4 streamers.\n\njulia> array(f, \"t1/mynum\")\n25-element Array{Int32,1}:\n  0\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 10\n 10\n 10\n 10\n 10\n 10\n 10\n 10\n 10\n 10\n 10\n 10\n 10\n 10","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"There is also a raw keyword which you can pass to array(), so it will skip the interpretation and return the raw bytes. This is similar to uproot.asdebug and can be used to read data where the streamers are not available (yet). Here is it in action, using some data from the KM3NeT experiment:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"julia> using UnROOT\n\njulia> f = ROOTFile(\"test/samples/km3net_online.root\")\nROOTFile(\"test/samples/km3net_online.root\") with 10 entries and 41 streamers.\n\njulia> array(f, \"KM3NET_EVENT/KM3NET_EVENT/triggeredHits\"; raw=true)\n2058-element Array{UInt8,1}:\n 0x00\n 0x03\n 0x00\n 0x01\n 0x00\n   â‹®\n 0x56\n 0x45\n 0x4e\n 0x54\n 0x00","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"This is what happens behind the scenes with some additional debug output:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"julia> using UnROOT\n\njulia> f = ROOTFile(\"test/samples/tree_with_histos.root\")\nCompressed stream at 1509\nROOTFile(\"test/samples/tree_with_histos.root\") with 1 entry and 4 streamers.\n\njulia> keys(f)\n1-element Array{String,1}:\n \"t1\"\n\njulia> keys(f[\"t1\"])\nCompressed datastream of 1317 bytes at 1509 (TKey 't1' (TTree))\n2-element Array{String,1}:\n \"mynum\"\n \"myval\"\n\njulia> f[\"t1\"][\"mynum\"]\nCompressed datastream of 1317 bytes at 6180 (TKey 't1' (TTree))\nUnROOT.TBranch\n  cursor: UnROOT.Cursor\n  fName: String \"mynum\"\n  fTitle: String \"mynum/I\"\n  fFillColor: Int16 0\n  fFillStyle: Int16 1001\n  fCompress: Int32 101\n  fBasketSize: Int32 32000\n  fEntryOffsetLen: Int32 0\n  fWriteBasket: Int32 1\n  fEntryNumber: Int64 25\n  fIOFeatures: UnROOT.ROOT_3a3a_TIOFeatures\n  fOffset: Int32 0\n  fMaxBaskets: UInt32 0x0000000a\n  fSplitLevel: Int32 0\n  fEntries: Int64 25\n  fFirstEntry: Int64 0\n  fTotBytes: Int64 170\n  fZipBytes: Int64 116\n  fBranches: UnROOT.TObjArray\n  fLeaves: UnROOT.TObjArray\n  fBaskets: UnROOT.TObjArray\n  fBasketBytes: Array{Int32}((10,)) Int32[116, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  fBasketEntry: Array{Int64}((10,)) [0, 25, 0, 0, 0, 0, 0, 0, 0, 0]\n  fBasketSeek: Array{Int64}((10,)) [238, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  fFileName: String \"\"\n\n\njulia> seek(f.fobj, 238)\nIOStream(<file test/samples/tree_with_histos.root>)\n\njulia> basketkey = UnROOT.unpack(f.fobj, UnROOT.TKey)\nUnROOT.TKey64(116, 1004, 100, 0x6526eafb, 70, 0, 238, 100, \"TBasket\", \"mynum\", \"t1\")\n\njulia> s = UnROOT.datastream(f.fobj, basketkey)\nCompressed datastream of 100 bytes at 289 (TKey 'mynum' (TBasket))\nIOBuffer(data=UInt8[...], readable=true, writable=false, seekable=true, append=false, size=100, maxsize=Inf, ptr=1, mark=-1)\n\njulia> [UnROOT.readtype(s, Int32) for _ in 1:f[\"t1\"][\"mynum\"].fEntries]\nCompressed datastream of 1317 bytes at 6180 (TKey 't1' (TTree))\n25-element Array{Int32,1}:\n  0\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 10\n 10\n 10\n 10\n 10\n 10\n 10\n 10\n 10\n 10\n 10\n 10\n 10\n 10","category":"page"},{"location":"#Main-challenges-1","page":"Introduction","title":"Main challenges","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"ROOT data is generally stored as big endian and is a self-descriptive format, i.e. so-called streamers are stored in the files which describe the actual structure of the data in the corresponding branches. These streamers are read during runtime and need to be used to generate Julia structs and unpack methods on the fly.\nPerformance is very important for a low level I/O library.","category":"page"},{"location":"#Low-hanging-fruits-1","page":"Introduction","title":"Low hanging fruits","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pick one ;)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"[x] Parsing the file header\n[x] Read the TKeys of the top level dictionary\n[x] Reading the available trees\n[ ] Reading the available streamers\n[x] Reading a simple dataset with primitive streamers\n[x] Reading of raw basket bytes for debugging\n[ ] Automatically generate streamer logic","category":"page"},{"location":"#Acknowledgements-1","page":"Introduction","title":"Acknowledgements","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Special thanks to Jim Pivarski (@jpivarski) from the Scikit-HEP project, who is the main author of uproot, a native Python library to read and write ROOT files, which was and is a great source of inspiration and information for reverse engineering the ROOT binary structures.","category":"page"}]
}
