var documenterSearchIndex = {"docs":
[{"location":"internalapis/#Commonly-used","page":"APIs","title":"Commonly used","text":"","category":"section"},{"location":"internalapis/","page":"APIs","title":"APIs","text":"Modules = [UnROOT]\nFilter   = t -> contains(string(t), \"Lazy\")","category":"page"},{"location":"internalapis/#UnROOT.LazyBranch","page":"APIs","title":"UnROOT.LazyBranch","text":"LazyBranch(f::ROOTFile, branch)\n\nConstruct an accessor for a given branch such that BA[idx] and or BA[1:20] is type-stable. And memory footprint is a single basket (<1MB usually). You can also iterate or map over it. If you want a concrete Vector, simply collect() the LazyBranch.\n\nExample\n\njulia> rf = ROOTFile(\"./test/samples/tree_with_large_array.root\");\n\njulia> b = rf[\"t1/int32_array\"];\n\njulia> ab = UnROOT.LazyBranch(rf, b);\n\njulia> for entry in ab\n           @show entry\n           break\n       end\nentry = 0\n\njulia> ab[begin:end]\n0\n1\n...\n\n\n\n\n\n","category":"type"},{"location":"internalapis/#UnROOT.LazyTree-Tuple{ROOTFile, AbstractString, Any}","page":"APIs","title":"UnROOT.LazyTree","text":"LazyTree(f::ROOTFile, s::AbstractString, branch::Union{AbstractString, Regex})\nLazyTree(f::ROOTFile, s::AbstractString, branch::Vector{Union{AbstractString, Regex}})\n\nConstructor for LazyTree, which is close to an DataFrame (interface wise), and a lazy Table (speed wise). Looping over a LazyTree is fast and type stable. Internally, LazyTree contains a typed table whose branch are LazyBranch. This means that at any given time only N baskets are cached, where N is the number of branches.\n\nnote: Note\nAccessing with [start:stop] will return a LazyTree with concrete internal table.\n\nwarning: Warning\nSplit branches are re-named, and the exact renaming may change. See  Issue 156 for context.\n\nExample\n\njulia> mytree = LazyTree(f, \"Events\", [\"Electron_dxy\", \"nMuon\", r\"Muon_(pt|eta)$\"])\n Row │ Electron_dxy     nMuon   Muon_eta         Muon_pt\n     │ Vector{Float32}  UInt32  Vector{Float32}  Vector{Float32}\n─────┼───────────────────────────────────────────────────────────\n 1   │ [0.000371]       0       []               []\n 2   │ [-0.00982]       2       [0.53, 0.229]    [19.9, 15.3]\n 3   │ []               0       []               []\n 4   │ [-0.00157]       0       []               []\n ⋮   │     ⋮            ⋮             ⋮                ⋮\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.LazyTree-Tuple{ROOTFile, UnROOT.TTree, Any, Any}","page":"APIs","title":"UnROOT.LazyTree","text":"function LazyTree(f::ROOTFile, tree::TTree, treepath, branches; sink = LazyTree)\n\nCreates a lazy tree object of the selected branches only. branches is vector of String, Regex or Pair{Regex, SubstitutionString}, where the first item is the regex selector and the second item the rename pattern. An alternative  container can be used by providing a sink function. The sink function must take as argument an table with a Tables.jl interface. The table columns are filled with  LazyBranch objects.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#More-Internal","page":"APIs","title":"More Internal","text":"","category":"section"},{"location":"internalapis/","page":"APIs","title":"APIs","text":"Modules = [UnROOT]\nFilter   = t -> !(contains(string(t), \"Lazy\"))","category":"page"},{"location":"internalapis/#UnROOT.Cursor","page":"APIs","title":"UnROOT.Cursor","text":"The Cursor type is embedded into Branches of a TTree such that when we need to read the content of a Branch, we don't need to go through the Directory and find the TKey and then seek to where the Branch is.\n\nnote: Note\nThe io inside a Cursor is in fact only a buffer, it is NOT a io that refers to the whole file's stream.\n\n\n\n\n\n","category":"type"},{"location":"internalapis/#UnROOT.LeafField","page":"APIs","title":"UnROOT.LeafField","text":"struct LeafField{T}\n    content_col_idx::Int\n    columnrecord::ColumnRecord\nend\n\nBase case of field nesting, this links to a column in the RNTuple by 0-based index. T is the eltype of this field which mostly uses Julia native types except for Switch.\n\nThe type field is the RNTuple spec type number, used to record split encoding.\n\n\n\n\n\n","category":"type"},{"location":"internalapis/#UnROOT.OffsetBuffer","page":"APIs","title":"UnROOT.OffsetBuffer","text":"OffsetBuffer\n\nWorks with seek, position of the original file. Think of it as a view of IOStream that can be indexed with original positions.\n\n\n\n\n\n","category":"type"},{"location":"internalapis/#UnROOT.Preamble-Union{Tuple{T}, Tuple{Any, Type{T}}} where T","page":"APIs","title":"UnROOT.Preamble","text":"Reads the preamble of an object.\n\nThe cursor will be put into the right place depending on the data.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.RNTuple","page":"APIs","title":"UnROOT.RNTuple","text":"RNTuple\n\nThis is the struct for holding all metadata (schema) needed to completely describe and RNTuple from ROOT, just like TTree, to obtain a table-like data object, you need to use LazyTree explicitly:\n\nExample\n\njulia> f = ROOTFile(\"./test/samples/RNTuple/test_ntuple_stl_containers.root\");\n\njulia> f[\"ntuple\"]\nUnROOT.RNTuple:\n  header:\n    name: \"ntuple\"\n    ntuple_description: \"\"\n    writer_identifier: \"ROOT v6.29/01\"\n    schema:\n      RNTupleSchema with 13 top fields\n      ├─ :lorentz_vector ⇒ Struct\n      ├─ :vector_tuple_int32_string ⇒ Vector\n      ├─ :string ⇒ String\n      ├─ :vector_string ⇒ Vector\n...\n..\n.\n\njulia> LazyTree(f, \"ntuple\")\n Row │ string  vector_int32     array_float      vector_vector_i     vector_string       vector_vector_s     variant_int32_s  vector_variant_     ⋯\n     │ String  Vector{Int32}    StaticArraysCor  Vector{Vector{I     Vector{String}      Vector{Vector{S     Union{Int32, St  Vector{Union{In     ⋯\n─────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n 1   │ one     [1]              [1.0, 1.0, 1.0]  Vector{Int32}[Int3  [\"one\"]             [[\"one\"]]           1                Union{Int64, Strin  ⋯\n 2   │ two     [1, 2]           [2.0, 2.0, 2.0]  Vector{Int32}[Int3  [\"one\", \"two\"]      [[\"one\"], [\"two\"]]  two              Union{Int64, Strin  ⋯\n 3   │ three   [1, 2, 3]        [3.0, 3.0, 3.0]  Vector{Int32}[Int3  [\"one\", \"two\", \"th  [[\"one\"], [\"two\"],  three            Union{Int64, Strin  ⋯\n 4   │ four    [1, 2, 3, 4]     [4.0, 4.0, 4.0]  Vector{Int32}[Int3  [\"one\", \"two\", \"th  [[\"one\"], [\"two\"],  4                Union{Int64, Strin  ⋯\n 5   │ five    [1, 2, 3, 4, 5]  [5.0, 5.0, 5.0]  Vector{Int32}[Int3  [\"one\", \"two\", \"th  [[\"one\"], [\"two\"],  5                Union{Int64, Strin  ⋯\n                                                                                                                                  5 columns omitted\n\n\n\n\n\n","category":"type"},{"location":"internalapis/#UnROOT.RNTupleCardinality","page":"APIs","title":"UnROOT.RNTupleCardinality","text":"struct RNTupleCardinality{T}\n    content_col_idx::Int\n    nbits::Int\nend\n\nSpecial field. The cardinality is basically a counter, but the data column is a leaf column of Index32 or Index64. To get a number from Cardinality, one needs to compute ary[i] - ary[i-1].\n\n\n\n\n\n","category":"type"},{"location":"internalapis/#UnROOT.RNTupleField","page":"APIs","title":"UnROOT.RNTupleField","text":"mutable struct RNTupleField{R, F, O, E} <: AbstractVector{E}\n\nNot a counterpart of RNTuple field in ROOT. This is a user-facing Julia-only construct like LazyBranch that is meant to act like a lazy AbstractVector backed with file IO source and a schema field from RNTuple.schema.\n\nR is the type of parent RNTuple\nF is the type of the field in the schema\n'O' is the type of output when you read a cluster-worth of data\n'E' is the element type of O (i.e. what you get for each event (row) in iteration)\n\n\n\n\n\n","category":"type"},{"location":"internalapis/#UnROOT.RNTupleSchema","page":"APIs","title":"UnROOT.RNTupleSchema","text":"struct RNTupleSchema\n\nA wrapper struct for print_tree implementation of the schema display.\n\nExample\n\njulia> f = ROOTFile(\"./test/samples/RNTuple/test_ntuple_stl_containers.root\");\n\njulia> f[\"ntuple\"].schema\nRNTupleSchema with 13 top fields\n├─ :lorentz_vector ⇒ Struct\n│                    ├─ :pt ⇒ Leaf{Float32}(col=26)\n│                    ├─ :eta ⇒ Leaf{Float32}(col=27)\n│                    ├─ :phi ⇒ Leaf{Float32}(col=28)\n│                    └─ :mass ⇒ Leaf{Float32}(col=29)\n├─ :vector_tuple_int32_string ⇒ Vector\n│                               ├─ :offset ⇒ Leaf{Int32}(col=9)\n│                               └─ :content ⇒ Struct\n│                                             ├─ :_1 ⇒ String\n│                                             │        ├─ :offset ⇒ Leaf{Int32}(col=37)\n│                                             │        └─ :content ⇒ Leaf{Char}(col=38)\n│                                             └─ :_0 ⇒ Leaf{Int32}(col=36)\n├─ :string ⇒ String\n│            ├─ :offset ⇒ Leaf{Int32}(col=1)\n│            └─ :content ⇒ Leaf{Char}(col=2)\n├─ :vector_string ⇒ Vector\n│                   ├─ :offset ⇒ Leaf{Int32}(col=5)\n│                   └─ :content ⇒ String\n│                                 ├─ :offset ⇒ Leaf{Int32}(col=13)\n│                                 └─ :content ⇒ Leaf{Char}(col=14)\n...\n..\n.\n\n\n\n\n\n","category":"type"},{"location":"internalapis/#UnROOT.ROOTFile-Tuple{AbstractString}","page":"APIs","title":"UnROOT.ROOTFile","text":"ROOTFile(filename::AbstractString; customstructs = Dict(\"TLorentzVector\" => LorentzVector{Float64}))\n\nROOTFile's constructor from a file. The customstructs dictionary can be used to pass user-defined struct as value and its corresponding fClassName (in Branch) as key such that UnROOT will know to interpret them, see interped_data.\n\nSee also: LazyTree, LazyBranch\n\nExample\n\njulia> f = ROOTFile(\"test/samples/NanoAODv5_sample.root\")\nROOTFile with 2 entries and 21 streamers.\ntest/samples/NanoAODv5_sample.root\n└─ Events\n   ├─ \"run\"\n   ├─ \"luminosityBlock\"\n   ├─ \"event\"\n   ├─ \"HTXS_Higgs_pt\"\n   ├─ \"HTXS_Higgs_y\"\n   └─ \"⋮\"\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.StdArrayField","page":"APIs","title":"UnROOT.StdArrayField","text":"StdArrayField<N, T>\n\nSpecial base-case field for a leaf field representing std::array<T, N>. This is because RNTuple would serialize it as a leaf field but with flags == 0x0001 in the field description. In total, there are two field descriptions associlated with array<>, one for meta-data (the N), the other one for the actual data.\n\n\n\n\n\n","category":"type"},{"location":"internalapis/#UnROOT.Streamers-Tuple{Any}","page":"APIs","title":"UnROOT.Streamers","text":"function Streamers(io)\n\nReads all the streamers from the ROOT source.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.StringField","page":"APIs","title":"UnROOT.StringField","text":"StringField\n\nSpecial base-case field for String leaf field. This is because RNTuple splits a leaf String field into two columns (instead of split in field records). So we need an offset column and a content column (that contains Chars).\n\n\n\n\n\n","category":"type"},{"location":"internalapis/#UnROOT.TH-Tuple{Any, Union{UnROOT.TKey32, UnROOT.TKey64}, Any}","page":"APIs","title":"UnROOT.TH","text":"TH(io, tkey::TKey, refs)\n\nInternal function used to form a fields = Dict{Symbol, Any}() that represents the fields of a TH (histogram) in C++ ROOT.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT._field_output_type-Tuple{}","page":"APIs","title":"UnROOT._field_output_type","text":"_field_output_type(::Type{F}) where F\n\nThis is function is used in two ways:\n\nprovide a output type prediction for each \"field\" in RNTuple so we can\n\nachieve type stability\n\nit's also used to enforce the type stability in read_field:\n\n    # this is basically a type assertion for `res`\n    return res::_field_output_type(field)\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT._rntuple_clusterrange-Tuple{Any}","page":"APIs","title":"UnROOT._rntuple_clusterrange","text":"The event number range a given cluster covers, in Julia's index\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.array-Tuple{ROOTFile, AbstractString}","page":"APIs","title":"UnROOT.array","text":"array(f::ROOTFile, path; raw=false)\n\nReads an array from a branch. Set raw=true to return raw data and correct offsets.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.arrays-Tuple{ROOTFile, Any}","page":"APIs","title":"UnROOT.arrays","text":"arrays(f::ROOTFile, treename)\n\nReads all branches from a tree.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.auto_T_JaggT-Tuple{ROOTFile, Any}","page":"APIs","title":"UnROOT.auto_T_JaggT","text":"auto_T_JaggT(f::ROOTFile, branch; customstructs::Dict{String, Type})\n\nGiven a file and branch, automatically return (eltype, Jaggtype). This function is aware of custom structs that are carried with the parent ROOTFile.\n\nThis is also where you may want to \"redirect\" classname -> Julia struct name, for example \"TLorentzVector\" => LorentzVector here and you can focus on LorentzVectors.LorentzVector methods from here on.\n\nSee also: ROOTFile, interped_data\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.basketarray-Tuple{ROOTFile, AbstractString, Any}","page":"APIs","title":"UnROOT.basketarray","text":"basketarray(f::ROOTFile, path::AbstractString, ith)\nbasketarray(f::ROOTFile, branch::Union{TBranch, TBranchElement}, ith)\nbasketarray(lb::LazyBranch, ith)\n\nReads actual data from ith basket of a branch. This function first calls readbasket to obtain raw bytes and offsets of a basket, then calls auto_T_JaggT followed by interped_data to translate raw bytes into actual data.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.basketarray_iter-Tuple{ROOTFile, Any}","page":"APIs","title":"UnROOT.basketarray_iter","text":"basketarray_iter(f::ROOTFile, branch::Union{TBranch, TBranchElement})\nbasketarray_iter(lb::LazyBranch)\n\nReturns a Base.Generator yielding the output of basketarray() for all baskets.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.chaintrees-Tuple{Any}","page":"APIs","title":"UnROOT.chaintrees","text":"chaintrees(ts)\n\nChain a collection of LazyTrees together to form a larger tree, every tree should have identical branch names and types, we're not trying to re-implement SQL here.\n\nExample\n\njulia> typeof(tree)\nLazyTree with 1 branches:\na\n\njulia> tree2 = UnROOT.chaintrees([tree,tree]);\n\njulia> eltype(tree.a) == eltype(tree2.a)\ntrue\n\njulia> length(tree)\n100\n\njulia> length(tree2)\n200\n\njulia> eltype(tree)\nUnROOT.LazyEvent{NamedTuple{(:a,), Tuple{LazyBranch{Int32, UnROOT.Nojagg, Vector{Int32}}}}}\n\njulia> eltype(tree2)\nUnROOT.LazyEvent{NamedTuple{(:a,), Tuple{SentinelArrays.ChainedVector{Int32, LazyBranch{Int32, UnROOT.Nojagg, Vector{Int32}}}}}}\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.compressed_datastream-Tuple{Any, Any}","page":"APIs","title":"UnROOT.compressed_datastream","text":"compressed_datastream(io, tkey)\n\nExtract all [compressionheader][rawbytes] from a TKey. This is an isolated function because we want to compartmentalize disk I/O as much as possible.\n\nSee also: decompress_datastreambytes\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.decompress_datastreambytes-Tuple{Any, Any}","page":"APIs","title":"UnROOT.decompress_datastreambytes","text":"decompress_datastreambytes(compbytes, tkey)\n\nProcess the compressed bytes compbytes which was read out by compressed_datastream and pointed to from tkey. This function simply return uncompressed bytes according to the compression algorithm detected (or the lack of).\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.endcheck-Union{Tuple{T}, Tuple{Any, T}} where T<:UnROOT.Preamble","page":"APIs","title":"UnROOT.endcheck","text":"function endcheck(io, preamble::Preamble)\n\nChecks if everything went well after parsing a TObject. Used in conjunction with Preamble.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.interped_data-Tuple{Any, Any, Type{Bool}, Type{UnROOT.Nojagg}}","page":"APIs","title":"UnROOT.interped_data","text":"interped_data(rawdata, rawoffsets, ::Type{T}, ::Type{J}) where {T, J<:JaggType}\n\nThe function thats interpret raw bytes (from a basket) into corresponding Julia data, based on type T and jagg type J.\n\nIn order to retrieve data from custom branches, user should defined more speialized method of this function with specific T and J. See TLorentzVector example.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.interped_data-Tuple{Any, Any, Type{Vector{LorentzVectors.LorentzVector{Float64}}}, Type{UnROOT.Offsetjagg}}","page":"APIs","title":"UnROOT.interped_data","text":"interped_data(rawdata, rawoffsets, ::Type{Vector{LorentzVector{Float64}}}, ::Type{Offsetjagg})\n\nThe interped_data method specialized for LorentzVector. This method will get called by basketarray instead of the default method for TLorentzVector branch.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.isvoid-Tuple{Type{Tuple{}}}","page":"APIs","title":"UnROOT.isvoid","text":"isvoid(::Type{T})\n\nInternal function to determine (by only looking at the type) if a RNTuple field is recursively empty. A field is empty is there's no more data column attached to it from this point forward.\n\nFor example, the :_0 field is empty here:\n\n├─ Symbol(\"AntiKt4TruthDressedWZJetsAux:\") ⇒ Struct\n│                                            ├─ :m ⇒ Vector\n│                                            │       ├─ :offset ⇒ Leaf{UnROOT.Index64}(col=23)\n│                                            │       └─ :content ⇒ Leaf{Float32}(col=24)\n│                                            ├─ Symbol(\":_0\") ⇒ Struct\n│                                            │                  ├─ Symbol(\":_2\") ⇒ Struct\n│                                            │                  ├─ Symbol(\":_1\") ⇒ Struct\n│                                            │                  ├─ Symbol(\":_0\") ⇒ Struct\n│                                            │                  │                  └─ Symbol(\":_0\") ⇒ Struct\n│                                            │                  └─ Symbol(\":_3\") ⇒ Struct\n\nWhen we parse the schema, we discard anything that cannot possibly produce redable data.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.parseTH-Tuple{Dict{Symbol, Any}}","page":"APIs","title":"UnROOT.parseTH","text":"parseTH(th::Dict{Symbol, Any}; raw=true) -> (counts, edges, sumw2, nentries)\nparseTH(th::Dict{Symbol, Any}; raw=false) -> Union{FHist.Hist1D, FHist.Hist2D}\n\nWhen raw=true, parse the output of TH into a tuple of counts, edges, sumw2, and nentries. When raw=false, parse the output of TH into FHist.jl histograms.\n\nExample\n\njulia> UnROOT.parseTH(UnROOT.samplefile(\"histograms1d2d.root\")[\"myTH1D\"])\n([40.0, 2.0], (-2.0:2.0:2.0,), [800.0, 2.0], 4.0)\n\njulia> UnROOT.parseTH(UnROOT.samplefile(\"histograms1d2d.root\")[\"myTH1D\"]; raw=false)\nedges: -2.0:2.0:2.0\nbin counts: [40.0, 2.0]\ntotal count: 42.0\n\n!!! note\nTH1 and TH2 inputs are supported.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.parsetobject-Tuple{Any, Union{UnROOT.TKey32, UnROOT.TKey64}, Any}","page":"APIs","title":"UnROOT.parsetobject","text":"Direct parsing of streamed objects which are not sitting on branches. This function needs to be rewritten, so that it can create proper types of TObject inherited data (like TVectorT<*>).\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.read_field-Tuple{}","page":"APIs","title":"UnROOT.read_field","text":"read_field(io, field::F, page_list) where F\n\nRead a field from the io stream. The page_list is a list of PageLinks for the current cluster group. The type stability is achieved by type asserting based on type F via _field_output_type function.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.read_field-Union{Tuple{T}, Tuple{N}, Tuple{Any, UnROOT.StructField{N, T}, Any}} where {N, T}","page":"APIs","title":"UnROOT.read_field","text":"read_field(io, field::StructField{N, T}, page_list) where {N, T}\n\nSince each field of the struct is stored in a separate field of the RNTuple, this function returns a StructArray to maximize efficiency.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.read_pagedesc-Tuple{Any, AbstractVector{UnROOT.PageDescription}, UnROOT.ColumnRecord}","page":"APIs","title":"UnROOT.read_pagedesc","text":"read_pagedesc(io, pagedescs::AbstractVector{PageDescription}, cr::ColumnRecord)\n\nRead the decompressed raw bytes given a Page Description. The nbits need to be provided according to the element type of the column since pagedesc only contains num_elements information.\n\nnote: Note\nWe handle split, zigzag, and delta encodings inside this function.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.readbasket-Tuple{ROOTFile, Any, Any}","page":"APIs","title":"UnROOT.readbasket","text":"readbasket(f::ROOTFile, branch, ith)\nreadbasketseek(f::ROOTFile, branch::Union{TBranch, TBranchElement}, seek_pos::Int, nbytes)\n\nThe fundamental building block of reading read data from a .root file. Read read one basket's raw bytes and offsets at a time. These raw bytes and offsets then (potentially) get processed by interped_data.\n\nSee also: auto_T_JaggT, basketarray\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.readobjany!-Tuple{Any, Union{UnROOT.TKey32, UnROOT.TKey64}, Any}","page":"APIs","title":"UnROOT.readobjany!","text":"function readobjany!(io, tkey::TKey, refs)\n\nThe main entrypoint where streamers are parsed and cached for later use. The refs dictionary holds the streamers or parsed data which are reused when already available.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.rnt_ary_to_page-Tuple{AbstractVector, UnROOT.ColumnRecord}","page":"APIs","title":"UnROOT.rnt_ary_to_page","text":"rnt_ary_to_page(ary::AbstractVector, cr::ColumnRecord) end\n\nTurns an AbstractVector into a page of an RNTuple. The element type must be primitive for this to work.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.rnt_col_to_ary-Tuple{AbstractVector{<:Real}}","page":"APIs","title":"UnROOT.rnt_col_to_ary","text":"rnt_col_to_ary(col) -> Vector{Vector}\n\nNormalize each user-facing \"column\" into a collection of Vector{<:Real} ready to be written to a page. After calling this on all user-facing \"column\", we should have as many arys as our ColumnRecords.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.rnt_write-Tuple{IO, UnROOT.ClusterGroupRecord}","page":"APIs","title":"UnROOT.rnt_write","text":"@SimpleStruct struct ClusterGroupRecord     minimumentrynumber::Int64     entryspan::Int64     numclusters::Int32     pagelistlink::EnvLink end\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.skiptobj-Tuple{Any}","page":"APIs","title":"UnROOT.skiptobj","text":"function skiptobj(io)\n\nSkips a TObject.\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.splitup-Tuple{Vector{UInt8}, Any, Type}","page":"APIs","title":"UnROOT.splitup","text":"splitup(data::Vector{UInt8}, offsets, T::Type; skipbytes=0)\n\nGiven the offsets and data return by array(...; raw = true), reconstructed the actual array (with custom struct, can be jagged as well).\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.topological_sort-Tuple{Any}","page":"APIs","title":"UnROOT.topological_sort","text":"function topological_sort(streamer_infos)\n\nSort the streamers with respect to their dependencies and keep only those which are not defined already.\n\nThe implementation is based on https://stackoverflow.com/a/11564769/1623645\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.unpack-Tuple{UnROOT.CompressionHeader}","page":"APIs","title":"UnROOT.unpack","text":"unpack(x::CompressionHeader)\n\nReturn the following information:\n\nName of compression algorithm\nLevel of the compression\ncompressedbytes and uncompressedbytes according to uproot3\n\n\n\n\n\n","category":"method"},{"location":"internalapis/#UnROOT.@SimpleStruct-Tuple{Any}","page":"APIs","title":"UnROOT.@SimpleStruct","text":"macro SimpleStruct\n\nDefine reading method on the fly for _rntuple_read\n\nExample\n\njulia> @SimpleStruct struct Locator\n           num_bytes::Int32\n           offset::UInt64\n       end\n\nwould automatically define the following reading method:\n\nfunction _rntuple_read(io, ::Type{Locator})\n    num_bytes = _rntuple_read(io, Int32)\n    offset = _rntuple_read(io, UInt64)\n    Locator(num_bytes, offset)\nend\n\nNotice _rntuple_read falls back to read for all types that are not defined by us.\n\n\n\n\n\n","category":"macro"},{"location":"internalapis/#UnROOT.@stack-Tuple{Any, Vararg{Any}}","page":"APIs","title":"UnROOT.@stack","text":"macro stack(into, structs...)\n\nStack the fields of multiple structs and create a new one. The first argument is the name of the new struct followed by the ones to be stacked. Parametric types are not supported and the fieldnames needs to be unique.\n\nExample:\n\n@stack Baz Foo Bar\n\nCreates Baz with the concatenated fields of Foo and Bar\n\n\n\n\n\n","category":"macro"},{"location":"advanced/custom_branch/#Parse-Custom-Branch","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"","category":"section"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"It is possible to parse Branches with custom structure as long as you know how the bytes should be interpreted. As an example, the TLorentzVector is added using this mechanism and we will walk through the steps needed:","category":"page"},{"location":"advanced/custom_branch/#1.-Provide-a-map-between-fClassName-of-your-struct-(as-seen-in-.root)-to-a-Julia-type.","page":"Parse Custom Branch","title":"1. Provide a map between fClassName of your struct (as seen in .root) to a Julia type.","text":"","category":"section"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"Pass a Dict{String, Type} to ROOTFile(filepath; customstructs). The TLorentzVector is shipped by default:","category":"page"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"ROOTFile(filepath; customstructs = Dict(\"TLorentzVector\" => LorentzVector{Float64}))","category":"page"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"This Dict will subsequently be used by the auto_T_JaggT function at here such that when we encounter a branch with this fClassName, we will return your Type as the detected element type of this branch.","category":"page"},{"location":"advanced/custom_branch/#2.-Extend-the-raw-bytes-interpreting-function-UnROOT.interped_data","page":"Parse Custom Branch","title":"2. Extend the raw bytes interpreting function UnROOT.interped_data","text":"","category":"section"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"By default, given a branch element type and a \"jaggness\" type, a general function is defined which will try to parse the raw bytes into Julia data structure. The ::Type{T} will match what you have provided in the Dict in the previous step.","category":"page"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"Thus, to \"teach\" UnROOT how to interpret bytes for your type T, you would want to defined a more specific UnROOT.interped_data than the default one. Taking the TLorentzVector as example again, we define a function:","category":"page"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"using LorentzVector\nconst LVF64 = LorentzVector{Float64}\nfunction UnROOT.interped_data(rawdata, rawoffsets, ::Type{LVF64}, ::Type{J}) where {T, J <: JaggType}\n    # `rawoffsets` is actually redundant, since we know each TLV is always 64 bytes (withe 32 bytes header)\n    [\n     reinterpret(LVF64, x) for x in Base.Iterators.partition(rawdata, 64)\n    ]\nend\n\n# VorView is defined in the `src/custom.jl`\nfunction Base.reinterpret(::Type{LVF64}, v::VorView) where T\n    # x,y,z,t in ROOT\n    v4 = ntoh.(reinterpret(Float64, v[1+32:end]))\n    # t,x,y,z in LorentzVectors.jl\n    LVF64(v4[4], v4[1], v4[2], v4[3])\nend","category":"page"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"The Base.reinterpret function is just a helper function, you could instead write everything inside UnROOT.interped_data. We then builds on these, to interpret Jagged TLV branch: https://github.com/JuliaHEP/UnROOT.jl/blob/4747f6f5fd97ed1a872765485b4eb9e99ec5a650/src/custom.jl#L47","category":"page"},{"location":"advanced/custom_branch/#More-details","page":"Parse Custom Branch","title":"More details","text":"","category":"section"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"To expand a bit what we're doing here, the rawdata for a single TLV is always 64 bytes long and the first 32 bytes are TObject header which we don't care (which is why we don't care about rawoffsets here). The last 32 bytes make up 4 Float64 and we simply parse them and return a collection of (julia) LorentzVector{Float64}.","category":"page"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"In general, if auto_T_JaggT returned MyType as promised branch element type, then","category":"page"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"UnROOT.interped_data(rawdata, rawoffsets, ::Type{MyType},","category":"page"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"should return Vector{MyType} because UnROOT.interped_data receives raw bytes of a basket at a time.","category":"page"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"And that's it! Afterwards both LazyBranch and LazyTree will be able to constructed with correct type and also knows how to interpret bytes when you indexing or iterating through them","category":"page"},{"location":"advanced/custom_branch/#Reading-Raw-Data-from-Branch","page":"Parse Custom Branch","title":"Reading Raw Data from Branch","text":"","category":"section"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"Alternatively, reading raw data is also possible using the UnROOT.array(f::ROOTFile, path; raw=true) method. The output can be then reinterpreted using a custom type with the method UnROOT.splitup(data, offsets, T::Type; skipbytes=0, jagged=true). This provides more fine grain control in case your branch is highly irregular. You can then define suitable Julia type and readtype method for parsing these data. Alternatively, you can of course parse the data and offsets entirely manually. Here is it in action, with the help of the types from custom.jl, and some data from the KM3NeT experiment:","category":"page"},{"location":"advanced/custom_branch/","page":"Parse Custom Branch","title":"Parse Custom Branch","text":"julia> using UnROOT\n\njulia> f = ROOTFile(\"test/samples/km3net_online.root\")\nROOTFile(\"test/samples/km3net_online.root\") with 10 entries and 41 streamers.\n\njulia> data, offsets = array(f, \"KM3NET_EVENT/KM3NET_EVENT/snapshotHits\"; raw=true)\n2058-element Array{UInt8,1}:\n 0x00\n 0x03\n   ⋮\n   \njulia> UnROOT.splitup(data, offsets, UnROOT._KM3NETDAQHit)\n4-element Vector{Vector{UnROOT._KM3NETDAQHit}}:\n [UnROOT._KM3NETDAQHit(1073742790, 0x00, 9, 0x60)......","category":"page"},{"location":"performancetips/#Don't-\"double-access\"","page":"Performance Tips","title":"Don't \"double access\"","text":"","category":"section"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"Inside an event-loop:","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"for evt in mytree\n    evt.nMuon!=4 && continue\n    calculation(evt.nMuon)\nend","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"This is bad practice. Since evt is a lazy construct, read happens when you access a property by e.g. evt.nMuon. This means that if you need a branch multiple times, you should allocate a variable first:","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"for evt in mytree\n    nmu = evt.nMuon\n    nmu !=4 && continue\n    calculation(nmu)\nend","category":"page"},{"location":"exampleusage/#Chunk-Iteration","page":"Example Usage","title":"Chunk Iteration","text":"","category":"section"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"t = LazyTree(...)\nres = 0.0\nfor rang in Iterators.partition(1:lastindex(t), 10^6)\n    res += sum(t[rang].nMuon) #\nend\nres","category":"page"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"Note, t[rang] is eager, if you don't need all branches, it's much better to use t.nMuon[rang], or limit which branches are selected during LazyTree() creation time.","category":"page"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"This pattern works the best over network, for local files, stick with:","category":"page"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"for evt in t\n    ...\nend","category":"page"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"usually is the best approach.","category":"page"},{"location":"exampleusage/#Writing-out-.root-files","page":"Example Usage","title":"Writing out .root files","text":"","category":"section"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"Currently UnROOT.jl is focused on reading only, however, it's semi-trivial to leverage Python world for write operation since it's not performance critical.","category":"page"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"You have the following choice:","category":"page"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"PythonCall.jl – we will demo how to use this one\nPyCall.jl","category":"page"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"Checkout configuration docs for PythonCall.jl","category":"page"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"Most importantly, you probably want to set:","category":"page"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"ENV[\"JULIA_PYTHONCALL_EXE\"] = readchomp(`which python`)","category":"page"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"before the using PythonCall line. Especially if you're using LCG or Athena or CMSSW environment.","category":"page"},{"location":"exampleusage/#Write-out-a-TTree","page":"Example Usage","title":"Write out a TTree","text":"","category":"section"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"julia> using PythonCall\n\njulia> const up = pyimport(\"uproot\")\n\njulia> pywith(up.recreate(\"./example.root\")) do file\n           file[\"mytree\"] = Dict(\"branch1\"=>1:1000, \"branch2\"=>rand(1000))\n       end\n\n# read it back with UnROOT.jl\njulia> using UnROOT\n\njulia> LazyTree(\"./example.root\", \"mytree\")\n Row │ branch1  branch2              \n     │ Int64    Float64              \n─────┼───────────────────────────────\n 1   │ 1        0.5775868298287866\n 2   │ 2        0.7245212475492369\n 3   │ 3        0.009249240901789912\n 4   │ 4        0.9010206670973542\n 5   │ 5        0.7609879879740359\n 6   │ 6        0.00916447384387542\n 7   │ 7        0.5636229077934333\n 8   │ 8        0.32617388561103156\n  ⋮  │    ⋮              ⋮","category":"page"},{"location":"exampleusage/#Write-out-a-histogram","page":"Example Usage","title":"Write out a histogram","text":"","category":"section"},{"location":"exampleusage/","page":"Example Usage","title":"Example Usage","text":"A histogram is just a tuple of (bincontent, binedges), see  FHist.jl docs for details.","category":"page"},{"location":"advanced/reduce_latency/#Bake-sysimage-with-PackageCompiler.jl","page":"Reduce startup latency","title":"Bake sysimage with PackageCompiler.jl","text":"","category":"section"},{"location":"advanced/reduce_latency/","page":"Reduce startup latency","title":"Reduce startup latency","text":"You can bake a sysimage tailored for your analysis to reduce latency.","category":"page"},{"location":"advanced/reduce_latency/","page":"Reduce startup latency","title":"Reduce startup latency","text":"> cat readtree.jl\nusing UnROOT\n\nconst r = ROOTFile(\"/home/akako/.julia/dev/UnROOT/test/samples/NanoAODv5_sample.root\")\n\nconst t = LazyTree(r, \"Events\", [\"nMuon\", \"Electron_dxy\"])\n\n\n@show t[1, :Electron_dxy]\n\n> time julia --startup-file=no readtree.jl\nt[1, :Electron_dxy] = Float32[0.00037050247]\n\n________________________________________________________\nExecuted in   10.82 secs    fish           external\n   usr time   11.09 secs  580.00 micros   11.09 secs\n   sys time    0.65 secs  189.00 micros    0.65 secs","category":"page"},{"location":"advanced/reduce_latency/","page":"Reduce startup latency","title":"Reduce startup latency","text":"In Julia, `]add PackageCompiler':","category":"page"},{"location":"advanced/reduce_latency/","page":"Reduce startup latency","title":"Reduce startup latency","text":"julia> using PackageCompiler\n\njulia> PackageCompiler.create_sysimage(:UnROOT; precompile_statements_file=\"./readtree.jl\", sysimage_path=\"./unroot.so\", replace_default=false)'","category":"page"},{"location":"advanced/reduce_latency/","page":"Reduce startup latency","title":"Reduce startup latency","text":"profit:","category":"page"},{"location":"advanced/reduce_latency/","page":"Reduce startup latency","title":"Reduce startup latency","text":"> time julia -J ./unroot.so readtree.jl \nt[1, :Electron_dxy] = Float32[0.00037050247]\n\n________________________________________________________\nExecuted in  619.20 millis    fish           external\n   usr time  902.29 millis    0.00 millis  902.29 millis\n   sys time  658.59 millis    1.05 millis  657.54 millis","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Apart from the pursue of performance, we also strive to provide intuitive and compostable interface. After all, \"theoretically\" fast doesn't mean the performance is accessible for the first-time physics user.","category":"page"},{"location":"#Status","page":"Introduction","title":"Status","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"We support reading all scalar and jagged branches of \"basic\" types, provide indexing and iteration interface with a \"per branch\" basket-cache. There is a low level API to provide interpretation functionalities for custom types and classes. As a metric, UnROOT can read all branches (~1800) of CMS NanoAOD including jagged TLorentzVector branch.","category":"page"},{"location":"#Loops-aren't-slow","page":"Introduction","title":"Loops aren't slow","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"One good thing about Julia is you can always fallback to writing loops since they are not intrinsically slower (than C/C++), certainly much faster than Python. Continuing the example from README:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using UnROOT\n\njulia> f = ROOTFile(\"test/samples/NanoAODv5_sample.root\")\n\njulia> mytree = LazyTree(f, \"Events\", [\"Electron_dxy\", \"nMuon\", r\"Muon_(pt|eta)$\"])","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"There are essentially two loops you can use:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> for event in mytree\n           ...\n       end\n\njulia> for (i, event) in enumerate(mytree)\n           # i will be index of `mytree`: 1, 2, 3...\n           ...\n       end","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Both of which are compostable with @threads for multi-threading:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> Threads.@threads for event in mytree\n           ...\n       end\n\njulia> Threads.@threads for (i, event) in enumerate(mytree)\n           ...\n       end","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Only one basket per branch will be cached so you don't have to worry about running out of RAM. At the same time, event inside the for-loop is not materialized until a field is accessed.","category":"page"},{"location":"#Laziness-in-Indexing,-Slicing,-and-Looping","page":"Introduction","title":"Laziness in Indexing, Slicing, and Looping","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Laziness (or eagerness) in UnROOT generally refers to if an \"event\" has read each branches of the tree or not. As canonical example of eager event, consider indexing:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> const r = LazyTree(ROOTFile(\"./Run2012BC_DoubleMuParked_Muons.root\"), \"Events\", [\"nMuon\", \"Muon_phi\"]);\n\njulia> names(r)\n2-element Vector{String}:\n \"Muon_phi\"\n \"nMuon\"\n\njulia> r[1]\n(Muon_phi = Float32[-0.034272723, 2.5426154], nMuon = 0x00000002)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Where the iterate() over tree is lazy:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> const r = LazyTree(ROOTFile(\"./Run2012BC_DoubleMuParked_Muons.root\"), \"Events\", [\"nMuon\", \"Muon_phi\"]);\n\njulia> for (i, evt) in enumerate(r)\n           @show i, evt\n           break\n       end\n(i, evt) = (1, \"LazyEvent with: (:tree, :idx)\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"And the reading of actual data is delayed until evt.nMuon or evt.Muon_phi happens. Which means you should be careful about: Don't-\"double-access\".","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The laziness of the main interfaces are summarized below:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":" mytree enumerate(mytree)\nfor X in ... 💤 💤\n@threads for X in ... 💤 💤\ngetindex(tree, row::Int) 💤 N/A\ngetindex(tree, row::Range) 🚨 N/A","category":"page"},{"location":"#Lazy-tree-construction","page":"Introduction","title":"Lazy tree construction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"As seen in the previous section, LazyTrees are cheap and offer a convenient way to create an object that isolates the branches of interest. It's fairly common that multiple branches are present with slightly differring names, like pos.x, pos.y etc. The LazyTree function also takes regular expressions, as seen in the example below where r\"Evt/trks/trks.pos.[xyz]\" is passed, that will match the corresponding branches:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> f = UnROOT.samplefile(\"km3net_offline.root\")\nROOTFile with 2 entries and 25 streamers.\n/Users/tamasgal/Dev/UnROOT.jl/test/samples/km3net_offline.root\n├─ E (TTree)\n│  └─ \"Evt\"\n└─ Header (Head)\n\njulia> t = LazyTree(f, \"E\", [\"Evt/trks/trks.id\", r\"Evt/trks/trks.pos.[xyz]\"])\n Row │ Evt_trks_trks_i   Evt_trks_trks_p  Evt_trks_trks_p  Evt_trks_trks_p      ⋯\n     │ SubArray{Int32,   SubArray{Float6  SubArray{Float6  SubArray{Float6      ⋯\n─────┼───────────────────────────────────────────────────────────────────────────\n 1   │ [1, 2, 3, 4, 5,   [615.0, 615.0,   [446.0, 446.0,   [125.0, 125.0, 70.7, ⋯\n 2   │ [1, 2, 3, 4, 5,   [533.0, 533.0,   [465.0, 465.0,   [80.7, 80.7, 39.1, 3 ⋯\n 3   │ [1, 2, 3, 4, 5,   [593.0, 593.0,   [457.0, 457.0,   [194.0, 194.0, 96.5, ⋯\n 4   │ [1, 2, 3, 4, 5,   [590.0, 590.0,   [440.0, 440.0,   [204.0, 204.0, 124.0 ⋯\n 5   │ [1, 2, 3, 4, 5,   [546.0, 546.0,   [440.0, 440.0,   [58.6, 58.6, 30.1, 3 ⋯\n 6   │ [1, 2, 3, 4, 5,   [585.0, 585.0,   [424.0, 424.0,   [202.0, 202.0, 183.0 ⋯\n 7   │ [1, 2, 3, 4, 5,   [533.0, 533.0,   [440.0, 440.0,   [47.3, 47.3, 30.1, 2 ⋯\n 8   │ [1, 2, 3, 4, 5,   [569.0, 569.0,   [469.0, 469.0,   [200.0, 200.0, 179.0 ⋯\n 9   │ [1, 2, 3, 4, 5,   [557.0, 557.0,   [412.0, 412.0,   [209.0, 209.0, 101.0 ⋯\n 10  │ [1, 2, 3, 4, 5,   [532.0, 532.0,   [443.0, 443.0,   [172.0, 172.0, 126.0 ⋯\n                                                                  1 column omitted\n\njulia> names(t)\n4-element Vector{String}:\n \"Evt_trks_trks_id\"\n \"Evt_trks_trks_pos_y\"\n \"Evt_trks_trks_pos_x\"\n \"Evt_trks_trks_pos_z\"\n\njulia> t.Evt_trks_trks_pos_y\n10-element LazyBranch{SubArray{Float64, 1, Vector{Float64}, Tuple{UnitRange{Int64}}, true},\nUnROOT.Nooffsetjagg, ArraysOfArrays.VectorOfVectors{Float64, Vector{Float64}, Vector{Int32},\nVector{Tuple{}}}}:\n [615.1089636184813, 615.1089636184813, … 574.836340445788, 576.5382993955498]\n ...\n ...","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Branch names are normalised so that they contain valid characters for identifiers. The branchname Evt/trks/trks.pos.y for example is therefore converted to Evt_trks_trks_posy, which might be a bit inconvenient to use. LazyTree can rename branches based on regular expressions and substitution strings (in Julia these are created with s\"\") which can be passed as Pairs. The example below shows how to use this:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> t = LazyTree(f, \"E\", [r\"Evt/trks/trks.(dir|pos).([xyz])\" => s\"\\1_\\2\"])\n Row │ pos_z                dir_z                pos_y                dir_y               ⋯\n     │ SubArray{Float6      SubArray{Float6      SubArray{Float6      SubArray{Float6     ⋯\n─────┼─────────────────────────────────────────────────────────────────────────────────────\n 1   │ [125.0, 125.0, 70.7  [-0.873, -0.873, -0  [615.0, 615.0, 585.  [-0.487, -0.487, -0 ⋯\n 2   │ [80.7, 80.7, 39.1,   [-0.835, -0.835, -0  [533.0, 533.0, 559.  [0.521, 0.521, 0.52 ⋯\n 3   │ [194.0, 194.0, 96.5  [-0.989, -0.989, -0  [593.0, 593.0, 581.  [-0.122, -0.122, -0 ⋯\n 4   │ [204.0, 204.0, 124.  [-0.968, -0.968, -0  [590.0, 590.0, 571.  [-0.23, -0.23, -0.2 ⋯\n 5   │ [58.6, 58.6, 30.1,   [-0.821, -0.821, -0  [546.0, 546.0, 565.  [0.54, 0.54, 0.54,  ⋯\n                                                                   2 columns omitted\n\njulia> names(t)\n6-element Vector{String}:\n \"pos_z\"\n \"dir_z\"\n \"pos_y\"\n \"dir_y\"\n \"dir_x\"\n \"pos_x\"","category":"page"},{"location":"devdocs/#Related-Projects","page":"For Contributors","title":"Related Projects","text":"","category":"section"},{"location":"devdocs/","page":"For Contributors","title":"For Contributors","text":"While the ROOT documentation does not contain a detailed description of the binary structure, the format can be triangulated by other packages like","category":"page"},{"location":"devdocs/","page":"For Contributors","title":"For Contributors","text":"uproot3 (Python), see also UpROOT.jl\ngroot (Go)\nroot-io (Rust)\nLaurelin (Java)","category":"page"},{"location":"devdocs/","page":"For Contributors","title":"For Contributors","text":"Here's a detailed from-scratch walk through  on reading a jagged branch from a ROOT file, recommended for first time contributors or those who just want to learn about ROOT file format.","category":"page"},{"location":"devdocs/","page":"For Contributors","title":"For Contributors","text":"Three's also a discussion reagarding the ROOT binary format documentation on uproot's issue page.","category":"page"}]
}
