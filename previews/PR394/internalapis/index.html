<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>APIs · UnROOT.jl</title><meta name="title" content="APIs · UnROOT.jl"/><meta property="og:title" content="APIs · UnROOT.jl"/><meta property="twitter:title" content="APIs · UnROOT.jl"/><meta name="description" content="Documentation for UnROOT.jl."/><meta property="og:description" content="Documentation for UnROOT.jl."/><meta property="twitter:description" content="Documentation for UnROOT.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">UnROOT.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../exampleusage/">Example Usage</a></li><li><a class="tocitem" href="../performancetips/">Performance Tips</a></li><li><span class="tocitem">Advanced Usage</span><ul><li><a class="tocitem" href="../advanced/custom_branch/">Parse Custom Branch</a></li><li><a class="tocitem" href="../advanced/reduce_latency/">Reduce startup latency</a></li></ul></li><li><a class="tocitem" href="../devdocs/">For Contributors</a></li><li class="is-active"><a class="tocitem" href>APIs</a><ul class="internal"><li><a class="tocitem" href="#Commonly-used"><span>Commonly used</span></a></li><li><a class="tocitem" href="#More-Internal"><span>More Internal</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>APIs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>APIs</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaHEP/UnROOT.jl/blob/main/docs/src/internalapis.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Commonly-used"><a class="docs-heading-anchor" href="#Commonly-used">Commonly used</a><a id="Commonly-used-1"></a><a class="docs-heading-anchor-permalink" href="#Commonly-used" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="UnROOT.LazyBranch"><a class="docstring-binding" href="#UnROOT.LazyBranch"><code>UnROOT.LazyBranch</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">LazyBranch(f::ROOTFile, branch)</code></pre><p>Construct an accessor for a given branch such that <code>BA[idx]</code> and or <code>BA[1:20]</code> is type-stable. And memory footprint is a single basket (&lt;1MB usually). You can also iterate or map over it. If you want a concrete <code>Vector</code>, simply <code>collect()</code> the LazyBranch.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; rf = ROOTFile(&quot;./test/samples/tree_with_large_array.root&quot;);

julia&gt; b = rf[&quot;t1/int32_array&quot;];

julia&gt; ab = UnROOT.LazyBranch(rf, b);

julia&gt; for entry in ab
           @show entry
           break
       end
entry = 0

julia&gt; ab[begin:end]
0
1
...</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/iteration.jl#LL95-L122">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.LazyTree-Tuple{ROOTFile, AbstractString, Any}"><a class="docstring-binding" href="#UnROOT.LazyTree-Tuple{ROOTFile, AbstractString, Any}"><code>UnROOT.LazyTree</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">LazyTree(f::ROOTFile, s::AbstractString, branch::Union{AbstractString, Regex})
LazyTree(f::ROOTFile, s::AbstractString, branch::Vector{Union{AbstractString, Regex}})</code></pre><p>Constructor for <code>LazyTree</code>, which is close to an <code>DataFrame</code> (interface wise), and a lazy Table (speed wise). Looping over a <code>LazyTree</code> is fast and type stable. Internally, <code>LazyTree</code> contains a typed table whose branch are <a href="#UnROOT.LazyBranch"><code>LazyBranch</code></a>. This means that at any given time only <code>N</code> baskets are cached, where <code>N</code> is the number of branches.</p><div class="admonition is-info" id="Note-6506a74b2a7df918"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-6506a74b2a7df918" title="Permalink"></a></header><div class="admonition-body"><p>Accessing with <code>[start:stop]</code> will return a <code>LazyTree</code> with concrete internal table.</p></div></div><div class="admonition is-warning" id="Warning-448f79deaa8e050d"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-448f79deaa8e050d" title="Permalink"></a></header><div class="admonition-body"><p>Split branches are re-named, and the exact renaming may change. See  <a href="https://github.com/JuliaHEP/UnROOT.jl/pull/156">Issue 156</a> for context.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; mytree = LazyTree(f, &quot;Events&quot;, [&quot;Electron_dxy&quot;, &quot;nMuon&quot;, r&quot;Muon_(pt|eta)$&quot;])
 Row │ Electron_dxy     nMuon   Muon_eta         Muon_pt
     │ Vector{Float32}  UInt32  Vector{Float32}  Vector{Float32}
─────┼───────────────────────────────────────────────────────────
 1   │ [0.000371]       0       []               []
 2   │ [-0.00982]       2       [0.53, 0.229]    [19.9, 15.3]
 3   │ []               0       []               []
 4   │ [-0.00157]       0       []               []
 ⋮   │     ⋮            ⋮             ⋮                ⋮</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/iteration.jl#LL376-L404">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.LazyTree-Tuple{ROOTFile, UnROOT.TTree, Any, Any}"><a class="docstring-binding" href="#UnROOT.LazyTree-Tuple{ROOTFile, UnROOT.TTree, Any, Any}"><code>UnROOT.LazyTree</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">function LazyTree(f::ROOTFile, tree::TTree, treepath, branches; sink = LazyTree)</code></pre><p>Creates a lazy tree object of the selected branches only. <code>branches</code> is vector of <code>String</code>, <code>Regex</code> or <code>Pair{Regex, SubstitutionString}</code>, where the first item is the regex selector and the second item the rename pattern. An alternative  container can be used by providing a sink function. The sink function must take as argument an table with a Tables.jl interface. The table columns are filled with  LazyBranch objects.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/iteration.jl#LL436-L446">source</a></div></details></article><h2 id="More-Internal"><a class="docs-heading-anchor" href="#More-Internal">More Internal</a><a id="More-Internal-1"></a><a class="docs-heading-anchor-permalink" href="#More-Internal" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="UnROOT.Cursor"><a class="docstring-binding" href="#UnROOT.Cursor"><code>UnROOT.Cursor</code></a> — <span class="docstring-category">Type</span></summary><div><p>The <code>Cursor</code> type is embedded into Branches of a TTree such that when we need to read the content of a Branch, we don&#39;t need to go through the Directory and find the TKey and then seek to where the Branch is.</p><div class="admonition is-info" id="Note-ac1372b13ae1d1fa"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-ac1372b13ae1d1fa" title="Permalink"></a></header><div class="admonition-body"><p>The <code>io</code> inside a <code>Cursor</code> is in fact only a buffer, it is NOT a <code>io</code> that refers to the whole file&#39;s stream.</p></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/io.jl#LL1-L9">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.LeafField"><a class="docstring-binding" href="#UnROOT.LeafField"><code>UnROOT.LeafField</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">struct LeafField{T}
    content_col_idx::Int
    columnrecord::ColumnRecord
end</code></pre><p>Base case of field nesting, this links to a column in the RNTuple by 0-based index. <code>T</code> is the <code>eltype</code> of this field which mostly uses Julia native types except for <code>Switch</code>.</p><p>The <code>type</code> field is the RNTuple spec type number, used to record split encoding.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/RNTuple/fieldcolumn_schema.jl#LL56-L67">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.OffsetBuffer"><a class="docstring-binding" href="#UnROOT.OffsetBuffer"><code>UnROOT.OffsetBuffer</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">OffsetBuffer</code></pre><p>Works with seek, position of the original file. Think of it as a view of IOStream that can be indexed with original positions.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/UnROOT.jl#LL28-L33">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.Preamble-Union{Tuple{T}, Tuple{Any, Type{T}}} where T"><a class="docstring-binding" href="#UnROOT.Preamble-Union{Tuple{T}, Tuple{Any, Type{T}}} where T"><code>UnROOT.Preamble</code></a> — <span class="docstring-category">Method</span></summary><div><p>Reads the preamble of an object.</p><p>The cursor will be put into the right place depending on the data.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/io.jl#LL90-L94">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.RNTuple"><a class="docstring-binding" href="#UnROOT.RNTuple"><code>UnROOT.RNTuple</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">RNTuple</code></pre><p>This is the struct for holding all metadata (schema) needed to completely describe and RNTuple from ROOT, just like <code>TTree</code>, to obtain a table-like data object, you need to use <code>LazyTree</code> explicitly:</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; f = ROOTFile(&quot;./test/samples/RNTuple/test_ntuple_stl_containers.root&quot;);

julia&gt; f[&quot;ntuple&quot;]
UnROOT.RNTuple:
  header:
    name: &quot;ntuple&quot;
    ntuple_description: &quot;&quot;
    writer_identifier: &quot;ROOT v6.29/01&quot;
    schema:
      RNTupleSchema with 13 top fields
      ├─ :lorentz_vector ⇒ Struct
      ├─ :vector_tuple_int32_string ⇒ Vector
      ├─ :string ⇒ String
      ├─ :vector_string ⇒ Vector
...
..
.

julia&gt; LazyTree(f, &quot;ntuple&quot;)
 Row │ string  vector_int32     array_float      vector_vector_i     vector_string       vector_vector_s     variant_int32_s  vector_variant_     ⋯
     │ String  Vector{Int32}    StaticArraysCor  Vector{Vector{I     Vector{String}      Vector{Vector{S     Union{Int32, St  Vector{Union{In     ⋯
─────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 1   │ one     [1]              [1.0, 1.0, 1.0]  Vector{Int32}[Int3  [&quot;one&quot;]             [[&quot;one&quot;]]           1                Union{Int64, Strin  ⋯
 2   │ two     [1, 2]           [2.0, 2.0, 2.0]  Vector{Int32}[Int3  [&quot;one&quot;, &quot;two&quot;]      [[&quot;one&quot;], [&quot;two&quot;]]  two              Union{Int64, Strin  ⋯
 3   │ three   [1, 2, 3]        [3.0, 3.0, 3.0]  Vector{Int32}[Int3  [&quot;one&quot;, &quot;two&quot;, &quot;th  [[&quot;one&quot;], [&quot;two&quot;],  three            Union{Int64, Strin  ⋯
 4   │ four    [1, 2, 3, 4]     [4.0, 4.0, 4.0]  Vector{Int32}[Int3  [&quot;one&quot;, &quot;two&quot;, &quot;th  [[&quot;one&quot;], [&quot;two&quot;],  4                Union{Int64, Strin  ⋯
 5   │ five    [1, 2, 3, 4, 5]  [5.0, 5.0, 5.0]  Vector{Int32}[Int3  [&quot;one&quot;, &quot;two&quot;, &quot;th  [[&quot;one&quot;], [&quot;two&quot;],  5                Union{Int64, Strin  ⋯
                                                                                                                                  5 columns omitted</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/RNTuple/highlevel.jl#LL135-L174">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.RNTupleCardinality"><a class="docstring-binding" href="#UnROOT.RNTupleCardinality"><code>UnROOT.RNTupleCardinality</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">struct RNTupleCardinality{T}
    content_col_idx::Int
    nbits::Int
end</code></pre><p>Special field. The cardinality is basically a counter, but the data column is a leaf column of Index32 or Index64. To get a number from Cardinality, one needs to compute <code>ary[i] - ary[i-1]</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/RNTuple/fieldcolumn_schema.jl#LL75-L84">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.RNTupleField"><a class="docstring-binding" href="#UnROOT.RNTupleField"><code>UnROOT.RNTupleField</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">mutable struct RNTupleField{R, F, O, E} &lt;: AbstractVector{E}</code></pre><p>Not a counterpart of RNTuple field in ROOT. This is a user-facing Julia-only construct like <code>LazyBranch</code> that is meant to act like a lazy <code>AbstractVector</code> backed with file IO source and a schema field from <code>RNTuple.schema</code>.</p><ul><li><code>R</code> is the type of parent <code>RNTuple</code></li><li><code>F</code> is the type of the field in the schema</li><li>&#39;O&#39; is the type of output when you read a cluster-worth of data</li><li>&#39;E&#39; is the element type of <code>O</code> (i.e. what you get for each event (row) in iteration)</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/RNTuple/highlevel.jl#LL1-L12">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.RNTupleSchema"><a class="docstring-binding" href="#UnROOT.RNTupleSchema"><code>UnROOT.RNTupleSchema</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">struct RNTupleSchema</code></pre><p>A wrapper struct for <code>print_tree</code> implementation of the schema display.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; f = ROOTFile(&quot;./test/samples/RNTuple/test_ntuple_stl_containers.root&quot;);

julia&gt; f[&quot;ntuple&quot;].schema
RNTupleSchema with 13 top fields
├─ :lorentz_vector ⇒ Struct
│                    ├─ :pt ⇒ Leaf{Float32}(col=26)
│                    ├─ :eta ⇒ Leaf{Float32}(col=27)
│                    ├─ :phi ⇒ Leaf{Float32}(col=28)
│                    └─ :mass ⇒ Leaf{Float32}(col=29)
├─ :vector_tuple_int32_string ⇒ Vector
│                               ├─ :offset ⇒ Leaf{Int32}(col=9)
│                               └─ :content ⇒ Struct
│                                             ├─ :_1 ⇒ String
│                                             │        ├─ :offset ⇒ Leaf{Int32}(col=37)
│                                             │        └─ :content ⇒ Leaf{Char}(col=38)
│                                             └─ :_0 ⇒ Leaf{Int32}(col=36)
├─ :string ⇒ String
│            ├─ :offset ⇒ Leaf{Int32}(col=1)
│            └─ :content ⇒ Leaf{Char}(col=2)
├─ :vector_string ⇒ Vector
│                   ├─ :offset ⇒ Leaf{Int32}(col=5)
│                   └─ :content ⇒ String
│                                 ├─ :offset ⇒ Leaf{Int32}(col=13)
│                                 └─ :content ⇒ Leaf{Char}(col=14)
...
..
.</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/RNTuple/highlevel.jl#LL50-L85">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.ROOTFile-Tuple{AbstractString}"><a class="docstring-binding" href="#UnROOT.ROOTFile-Tuple{AbstractString}"><code>UnROOT.ROOTFile</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">ROOTFile(filename::AbstractString; customstructs = Dict(&quot;TLorentzVector&quot; =&gt; LorentzVector{Float64}))</code></pre><p><code>ROOTFile</code>&#39;s constructor from a file. The <code>customstructs</code> dictionary can be used to pass user-defined struct as value and its corresponding <code>fClassName</code> (in Branch) as key such that <code>UnROOT</code> will know to interpret them, see <a href="#UnROOT.interped_data-Tuple{Any, Any, Type{Bool}, Type{UnROOT.Nojagg}}"><code>interped_data</code></a>.</p><p>See also: <a href="#UnROOT.LazyTree-Tuple{ROOTFile, AbstractString, Any}"><code>LazyTree</code></a>, <a href="#UnROOT.LazyBranch"><code>LazyBranch</code></a></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; f = ROOTFile(&quot;test/samples/NanoAODv5_sample.root&quot;)
ROOTFile with 2 entries and 21 streamers.
test/samples/NanoAODv5_sample.root
└─ Events
   ├─ &quot;run&quot;
   ├─ &quot;luminosityBlock&quot;
   ├─ &quot;event&quot;
   ├─ &quot;HTXS_Higgs_pt&quot;
   ├─ &quot;HTXS_Higgs_y&quot;
   └─ &quot;⋮&quot;</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/root.jl#LL42-L64">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.StdArrayField"><a class="docstring-binding" href="#UnROOT.StdArrayField"><code>UnROOT.StdArrayField</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">StdArrayField&lt;N, T&gt;</code></pre><p>Special base-case field for a leaf field representing <code>std::array&lt;T, N&gt;</code>. This is because RNTuple would serialize it as a leaf field but with <code>flags == 0x0001</code> in the field description. In total, there are two field descriptions associlated with <code>array&lt;&gt;</code>, one for meta-data (the <code>N</code>), the other one for the actual data.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/RNTuple/fieldcolumn_schema.jl#LL29-L36">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.Streamers-Tuple{Any}"><a class="docstring-binding" href="#UnROOT.Streamers-Tuple{Any}"><code>UnROOT.Streamers</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">function Streamers(io)</code></pre><p>Reads all the streamers from the ROOT source.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/streamers.jl#LL66-L70">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.StringField"><a class="docstring-binding" href="#UnROOT.StringField"><code>UnROOT.StringField</code></a> — <span class="docstring-category">Type</span></summary><div><pre><code class="language-julia hljs">StringField</code></pre><p>Special base-case field for String leaf field. This is because RNTuple splits a leaf String field into two columns (instead of split in field records). So we need an offset column and a content column (that contains <code>Char</code>s).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/RNTuple/fieldcolumn_schema.jl#LL43-L49">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.TH-Tuple{Any, Union{UnROOT.TKey32, UnROOT.TKey64}, Any}"><a class="docstring-binding" href="#UnROOT.TH-Tuple{Any, Union{UnROOT.TKey32, UnROOT.TKey64}, Any}"><code>UnROOT.TH</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">TH(io, tkey::TKey, refs)</code></pre><p>Internal function used to form a <code>fields = Dict{Symbol, Any}()</code> that represents the fields of a <code>TH</code> (histogram) in C++ ROOT.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/bootstrap.jl#LL994-L999">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT._field_output_type-Tuple{}"><a class="docstring-binding" href="#UnROOT._field_output_type-Tuple{}"><code>UnROOT._field_output_type</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">_field_output_type(::Type{F}) where F</code></pre><p>This is function is used in two ways:</p><ul><li>provide a output type prediction for each &quot;field&quot; in RNTuple so we can</li></ul><p>achieve type stability</p><ul><li>it&#39;s also used to enforce the type stability in <a href="#UnROOT.read_field-Tuple{}"><code>read_field</code></a>:</li></ul><pre><code class="language-julia hljs">    # this is basically a type assertion for `res`
    return res::_field_output_type(field)</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/RNTuple/fieldcolumn_reading.jl#LL1-L14">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT._rntuple_clusterrange-Tuple{Any}"><a class="docstring-binding" href="#UnROOT._rntuple_clusterrange-Tuple{Any}"><code>UnROOT._rntuple_clusterrange</code></a> — <span class="docstring-category">Method</span></summary><div><p>The event number range a given cluster covers, in Julia&#39;s index</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/RNTuple/highlevel.jl#LL34-L36">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.array-Tuple{ROOTFile, AbstractString}"><a class="docstring-binding" href="#UnROOT.array-Tuple{ROOTFile, AbstractString}"><code>UnROOT.array</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">array(f::ROOTFile, path; raw=false)</code></pre><p>Reads an array from a branch. Set <code>raw=true</code> to return raw data and correct offsets.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/iteration.jl#LL15-L19">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.arrays-Tuple{ROOTFile, Any}"><a class="docstring-binding" href="#UnROOT.arrays-Tuple{ROOTFile, Any}"><code>UnROOT.arrays</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">arrays(f::ROOTFile, treename)</code></pre><p>Reads all branches from a tree.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/iteration.jl#LL1-L5">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.auto_T_JaggT-Tuple{ROOTFile, Any}"><a class="docstring-binding" href="#UnROOT.auto_T_JaggT-Tuple{ROOTFile, Any}"><code>UnROOT.auto_T_JaggT</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">auto_T_JaggT(f::ROOTFile, branch; customstructs::Dict{String, Type})</code></pre><p>Given a file and branch, automatically return (eltype, Jaggtype). This function is aware of custom structs that are carried with the parent <code>ROOTFile</code>.</p><p>This is also where you may want to &quot;redirect&quot; classname -&gt; Julia struct name, for example <code>&quot;TLorentzVector&quot; =&gt; LorentzVector</code> here and you can focus on <code>LorentzVectors.LorentzVector</code> methods from here on.</p><p>See also: <a href="#UnROOT.ROOTFile-Tuple{AbstractString}"><code>ROOTFile</code></a>, <a href="#UnROOT.interped_data-Tuple{Any, Any, Type{Bool}, Type{UnROOT.Nojagg}}"><code>interped_data</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/root.jl#LL351-L362">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.basketarray-Tuple{ROOTFile, AbstractString, Any}"><a class="docstring-binding" href="#UnROOT.basketarray-Tuple{ROOTFile, AbstractString, Any}"><code>UnROOT.basketarray</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">basketarray(f::ROOTFile, path::AbstractString, ith)
basketarray(f::ROOTFile, branch::Union{TBranch, TBranchElement}, ith)
basketarray(lb::LazyBranch, ith)</code></pre><p>Reads actual data from ith basket of a branch. This function first calls <a href="#UnROOT.readbasket-Tuple{ROOTFile, Any, Any}"><code>readbasket</code></a> to obtain raw bytes and offsets of a basket, then calls <a href="#UnROOT.auto_T_JaggT-Tuple{ROOTFile, Any}"><code>auto_T_JaggT</code></a> followed by <a href="#UnROOT.interped_data-Tuple{Any, Any, Type{Bool}, Type{UnROOT.Nojagg}}"><code>interped_data</code></a> to translate raw bytes into actual data.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/iteration.jl#LL38-L46">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.basketarray_iter-Tuple{ROOTFile, Any}"><a class="docstring-binding" href="#UnROOT.basketarray_iter-Tuple{ROOTFile, Any}"><code>UnROOT.basketarray_iter</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">basketarray_iter(f::ROOTFile, branch::Union{TBranch, TBranchElement})
basketarray_iter(lb::LazyBranch)</code></pre><p>Returns a <code>Base.Generator</code> yielding the output of <code>basketarray()</code> for all baskets.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/iteration.jl#LL83-L88">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.chaintrees-Tuple{Any}"><a class="docstring-binding" href="#UnROOT.chaintrees-Tuple{Any}"><code>UnROOT.chaintrees</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">chaintrees(ts)</code></pre><p>Chain a collection of <code>LazyTree</code>s together to form a larger tree, every tree should have identical branch names and types, we&#39;re not trying to re-implement SQL here.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; typeof(tree)
LazyTree with 1 branches:
a

julia&gt; tree2 = UnROOT.chaintrees([tree,tree]);

julia&gt; eltype(tree.a) == eltype(tree2.a)
true

julia&gt; length(tree)
100

julia&gt; length(tree2)
200

julia&gt; eltype(tree)
UnROOT.LazyEvent{NamedTuple{(:a,), Tuple{LazyBranch{Int32, UnROOT.Nojagg, Vector{Int32}}}}}

julia&gt; eltype(tree2)
UnROOT.LazyEvent{NamedTuple{(:a,), Tuple{SentinelArrays.ChainedVector{Int32, LazyBranch{Int32, UnROOT.Nojagg, Vector{Int32}}}}}}</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/iteration.jl#LL321-L351">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.compressed_datastream-Tuple{Any, Any}"><a class="docstring-binding" href="#UnROOT.compressed_datastream-Tuple{Any, Any}"><code>UnROOT.compressed_datastream</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">compressed_datastream(io, tkey)</code></pre><p>Extract all [compressionheader][rawbytes] from a <code>TKey</code>. This is an isolated function because we want to compartmentalize disk I/O as much as possible.</p><p>See also: <a href="#UnROOT.decompress_datastreambytes-Tuple{Any, Any}"><code>decompress_datastreambytes</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/types.jl#LL117-L124">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.decompress_datastreambytes-Tuple{Any, Any}"><a class="docstring-binding" href="#UnROOT.decompress_datastreambytes-Tuple{Any, Any}"><code>UnROOT.decompress_datastreambytes</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">decompress_datastreambytes(compbytes, tkey)</code></pre><p>Process the compressed bytes <code>compbytes</code> which was read out by <code>compressed_datastream</code> and pointed to from <code>tkey</code>. This function simply return uncompressed bytes according to the compression algorithm detected (or the lack of).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/types.jl#LL135-L141">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.endcheck-Union{Tuple{T}, Tuple{Any, T}} where T&lt;:UnROOT.Preamble"><a class="docstring-binding" href="#UnROOT.endcheck-Union{Tuple{T}, Tuple{Any, T}} where T&lt;:UnROOT.Preamble"><code>UnROOT.endcheck</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">function endcheck(io, preamble::Preamble)</code></pre><p>Checks if everything went well after parsing a TObject. Used in conjunction with <code>Preamble</code>.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/io.jl#LL130-L135">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.interped_data-Tuple{Any, Any, Type{Bool}, Type{UnROOT.Nojagg}}"><a class="docstring-binding" href="#UnROOT.interped_data-Tuple{Any, Any, Type{Bool}, Type{UnROOT.Nojagg}}"><code>UnROOT.interped_data</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">interped_data(rawdata, rawoffsets, ::Type{T}, ::Type{J}) where {T, J&lt;:JaggType}</code></pre><p>The function thats interpret raw bytes (from a basket) into corresponding Julia data, based on type <code>T</code> and jagg type <code>J</code>.</p><p>In order to retrieve data from custom branches, user should defined more speialized method of this function with specific <code>T</code> and <code>J</code>. See <code>TLorentzVector</code> example.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/root.jl#LL237-L245">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.interped_data-Tuple{Any, Any, Type{Vector{LorentzVectors.LorentzVector{Float64}}}, Type{UnROOT.Offsetjagg}}"><a class="docstring-binding" href="#UnROOT.interped_data-Tuple{Any, Any, Type{Vector{LorentzVectors.LorentzVector{Float64}}}, Type{UnROOT.Offsetjagg}}"><code>UnROOT.interped_data</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">interped_data(rawdata, rawoffsets, ::Type{Vector{LorentzVector{Float64}}}, ::Type{Offsetjagg})</code></pre><p>The <code>interped_data</code> method specialized for <code>LorentzVector</code>. This method will get called by <a href="#UnROOT.basketarray-Tuple{ROOTFile, AbstractString, Any}"><code>basketarray</code></a> instead of the default method for <code>TLorentzVector</code> branch.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/custom.jl#LL107-L112">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.isvoid-Tuple{Type{Tuple{}}}"><a class="docstring-binding" href="#UnROOT.isvoid-Tuple{Type{Tuple{}}}"><code>UnROOT.isvoid</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">isvoid(::Type{T})</code></pre><p>Internal function to determine (by only looking at the type) if a RNTuple field is recursively empty. A field is empty is there&#39;s no more data column attached to it from this point forward.</p><p>For example, the :_0 field is empty here:</p><pre><code class="language-julia hljs">├─ Symbol(&quot;AntiKt4TruthDressedWZJetsAux:&quot;) ⇒ Struct
│                                            ├─ :m ⇒ Vector
│                                            │       ├─ :offset ⇒ Leaf{UnROOT.Index64}(col=23)
│                                            │       └─ :content ⇒ Leaf{Float32}(col=24)
│                                            ├─ Symbol(&quot;:_0&quot;) ⇒ Struct
│                                            │                  ├─ Symbol(&quot;:_2&quot;) ⇒ Struct
│                                            │                  ├─ Symbol(&quot;:_1&quot;) ⇒ Struct
│                                            │                  ├─ Symbol(&quot;:_0&quot;) ⇒ Struct
│                                            │                  │                  └─ Symbol(&quot;:_0&quot;) ⇒ Struct
│                                            │                  └─ Symbol(&quot;:_3&quot;) ⇒ Struct</code></pre><p>When we parse the schema, we discard anything that cannot possibly produce redable data.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/RNTuple/fieldcolumn_schema.jl#LL3-L25">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.parseTH-Tuple{Dict{Symbol, Any}}"><a class="docstring-binding" href="#UnROOT.parseTH-Tuple{Dict{Symbol, Any}}"><code>UnROOT.parseTH</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">parseTH(th::Dict{Symbol, Any}; raw=true) -&gt; (counts, edges, sumw2, nentries)
parseTH(th::Dict{Symbol, Any}; raw=false) -&gt; Union{FHist.Hist1D, FHist.Hist2D}</code></pre><p>When <code>raw=true</code>, parse the output of <a href="#UnROOT.TH-Tuple{Any, Union{UnROOT.TKey32, UnROOT.TKey64}, Any}"><code>TH</code></a> into a tuple of <code>counts</code>, <code>edges</code>, <code>sumw2</code>, and <code>nentries</code>. When <code>raw=false</code>, parse the output of <a href="#UnROOT.TH-Tuple{Any, Union{UnROOT.TKey32, UnROOT.TKey64}, Any}"><code>TH</code></a> into FHist.jl histograms.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; UnROOT.parseTH(UnROOT.samplefile(&quot;histograms1d2d.root&quot;)[&quot;myTH1D&quot;])
([40.0, 2.0], (-2.0:2.0:2.0,), [800.0, 2.0], 4.0)

julia&gt; UnROOT.parseTH(UnROOT.samplefile(&quot;histograms1d2d.root&quot;)[&quot;myTH1D&quot;]; raw=false)
edges: -2.0:2.0:2.0
bin counts: [40.0, 2.0]
total count: 42.0</code></pre><pre><code class="language-julia hljs">!!! note
TH1 and TH2 inputs are supported.</code></pre><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/utils.jl#LL100-L120">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.parsetobject-Tuple{Any, Union{UnROOT.TKey32, UnROOT.TKey64}, Any}"><a class="docstring-binding" href="#UnROOT.parsetobject-Tuple{Any, Union{UnROOT.TKey32, UnROOT.TKey64}, Any}"><code>UnROOT.parsetobject</code></a> — <span class="docstring-category">Method</span></summary><div><p>Direct parsing of streamed objects which are not sitting on branches. This function needs to be rewritten, so that it can create proper types of TObject inherited data (like <code>TVectorT&lt;*&gt;</code>).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/bootstrap.jl#LL1104-L1109">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.read_field-Tuple{}"><a class="docstring-binding" href="#UnROOT.read_field-Tuple{}"><code>UnROOT.read_field</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">read_field(io, field::F, page_list) where F</code></pre><p>Read a field from the <code>io</code> stream. The <code>page_list</code> is a list of PageLinks for the current cluster group. The type stability is achieved by type asserting based on type <code>F</code> via <a href="#UnROOT._field_output_type-Tuple{}"><code>_field_output_type</code></a> function.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/RNTuple/fieldcolumn_reading.jl#LL17-L23">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.read_field-Union{Tuple{T}, Tuple{N}, Tuple{Any, UnROOT.StructField{N, T}, Any}} where {N, T}"><a class="docstring-binding" href="#UnROOT.read_field-Union{Tuple{T}, Tuple{N}, Tuple{Any, UnROOT.StructField{N, T}, Any}} where {N, T}"><code>UnROOT.read_field</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">read_field(io, field::StructField{N, T}, page_list) where {N, T}</code></pre><p>Since each field of the struct is stored in a separate field of the RNTuple, this function returns a <code>StructArray</code> to maximize efficiency.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/RNTuple/fieldcolumn_reading.jl#LL139-L144">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.read_pagedesc-Tuple{Any, AbstractVector{UnROOT.PageDescription}, UnROOT.ColumnRecord}"><a class="docstring-binding" href="#UnROOT.read_pagedesc-Tuple{Any, AbstractVector{UnROOT.PageDescription}, UnROOT.ColumnRecord}"><code>UnROOT.read_pagedesc</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">read_pagedesc(io, pagedescs::AbstractVector{PageDescription}, cr::ColumnRecord)</code></pre><p>Read the decompressed raw bytes given a Page Description. The <code>nbits</code> need to be provided according to the element type of the column since <code>pagedesc</code> only contains <code>num_elements</code> information.</p><div class="admonition is-info" id="Note-12cf330c520317ad"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-12cf330c520317ad" title="Permalink"></a></header><div class="admonition-body"><p>We handle split, zigzag, and delta encodings inside this function.</p></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/RNTuple/fieldcolumn_reading.jl#LL193-L202">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.readbasket-Tuple{ROOTFile, Any, Any}"><a class="docstring-binding" href="#UnROOT.readbasket-Tuple{ROOTFile, Any, Any}"><code>UnROOT.readbasket</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">readbasket(f::ROOTFile, branch, ith)
readbasketseek(f::ROOTFile, branch::Union{TBranch, TBranchElement}, seek_pos::Int, nbytes)</code></pre><p>The fundamental building block of reading read data from a .root file. Read one basket&#39;s raw bytes and offsets at a time. These raw bytes and offsets then (potentially) get processed by <a href="#UnROOT.interped_data-Tuple{Any, Any, Type{Bool}, Type{UnROOT.Nojagg}}"><code>interped_data</code></a>.</p><p>See also: <a href="#UnROOT.auto_T_JaggT-Tuple{ROOTFile, Any}"><code>auto_T_JaggT</code></a>, <a href="#UnROOT.basketarray-Tuple{ROOTFile, AbstractString, Any}"><code>basketarray</code></a></p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/root.jl#LL544-L553">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.readobjany!-Tuple{Any, Union{UnROOT.TKey32, UnROOT.TKey64}, Any}"><a class="docstring-binding" href="#UnROOT.readobjany!-Tuple{Any, Union{UnROOT.TKey32, UnROOT.TKey64}, Any}"><code>UnROOT.readobjany!</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">function readobjany!(io, tkey::TKey, refs)</code></pre><p>The main entrypoint where streamers are parsed and cached for later use. The <code>refs</code> dictionary holds the streamers or parsed data which are reused when already available.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/streamers.jl#LL190-L196">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.rnt_ary_to_page-Tuple{AbstractVector, UnROOT.ColumnRecord}"><a class="docstring-binding" href="#UnROOT.rnt_ary_to_page-Tuple{AbstractVector, UnROOT.ColumnRecord}"><code>UnROOT.rnt_ary_to_page</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">rnt_ary_to_page(ary::AbstractVector, cr::ColumnRecord) end</code></pre><p>Turns an AbstractVector into a page of an RNTuple. The element type must be primitive for this to work.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/RNTuple/Writing/page_writing.jl#LL22-L27">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.rnt_col_to_ary-Tuple{AbstractVector{&lt;:Real}}"><a class="docstring-binding" href="#UnROOT.rnt_col_to_ary-Tuple{AbstractVector{&lt;:Real}}"><code>UnROOT.rnt_col_to_ary</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">rnt_col_to_ary(col) -&gt; Vector{Vector}</code></pre><p>Normalize each user-facing &quot;column&quot; into a collection of Vector{&lt;:Real} ready to be written to a page. After calling this on all user-facing &quot;column&quot;, we should have as many <code>ary</code>s as our <code>ColumnRecord</code>s and in the same order.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/RNTuple/Writing/page_writing.jl#LL1-L7">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.rnt_write-Tuple{IO, UnROOT.ClusterGroupRecord}"><a class="docstring-binding" href="#UnROOT.rnt_write-Tuple{IO, UnROOT.ClusterGroupRecord}"><code>UnROOT.rnt_write</code></a> — <span class="docstring-category">Method</span></summary><div><p>@SimpleStruct struct ClusterGroupRecord     minimum<em>entry</em>number::Int64     entry<em>span::Int64     num</em>clusters::Int32     page<em>list</em>link::EnvLink end</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/RNTuple/Writing/TFileWriter.jl#LL364-L371">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.skiptobj-Tuple{Any}"><a class="docstring-binding" href="#UnROOT.skiptobj-Tuple{Any}"><code>UnROOT.skiptobj</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">function skiptobj(io)</code></pre><p>Skips a TObject.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/io.jl#LL113-L117">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.splitup-Tuple{Vector{UInt8}, Any, Type}"><a class="docstring-binding" href="#UnROOT.splitup-Tuple{Vector{UInt8}, Any, Type}"><code>UnROOT.splitup</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">splitup(data::Vector{UInt8}, offsets, T::Type; skipbytes=0)</code></pre><p>Given the <code>offsets</code> and <code>data</code> return by <code>array(...; raw = true)</code>, reconstructed the actual array (with custom struct, can be jagged as well).</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/custom.jl#LL1-L6">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.topological_sort-Tuple{Any}"><a class="docstring-binding" href="#UnROOT.topological_sort-Tuple{Any}"><code>UnROOT.topological_sort</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">function topological_sort(streamer_infos)</code></pre><p>Sort the streamers with respect to their dependencies and keep only those which are not defined already.</p><p>The implementation is based on https://stackoverflow.com/a/11564769/1623645</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/streamers.jl#LL145-L152">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.unpack-Tuple{UnROOT.CompressionHeader}"><a class="docstring-binding" href="#UnROOT.unpack-Tuple{UnROOT.CompressionHeader}"><code>UnROOT.unpack</code></a> — <span class="docstring-category">Method</span></summary><div><pre><code class="language-julia hljs">unpack(x::CompressionHeader)</code></pre><p>Return the following information:</p><ul><li>Name of compression algorithm</li><li>Level of the compression</li><li>compressedbytes and uncompressedbytes according to <a href="https://github.com/scikit-hep/uproot3/blob/54f5151fb7c686c3a161fbe44b9f299e482f346b/uproot3/source/compressed.py#L132">uproot3</a></li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/utils.jl#LL35-L42">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.@SimpleStruct-Tuple{Any}"><a class="docstring-binding" href="#UnROOT.@SimpleStruct-Tuple{Any}"><code>UnROOT.@SimpleStruct</code></a> — <span class="docstring-category">Macro</span></summary><div><pre><code class="language-julia hljs">macro SimpleStruct</code></pre><p>Define reading method on the fly for <code>_rntuple_read</code></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; @SimpleStruct struct Locator
           num_bytes::Int32
           offset::UInt64
       end</code></pre><p>would automatically define the following reading method:</p><pre><code class="language-julia hljs">function _rntuple_read(io, ::Type{Locator})
    num_bytes = _rntuple_read(io, Int32)
    offset = _rntuple_read(io, UInt64)
    Locator(num_bytes, offset)
end</code></pre><p>Notice <code>_rntuple_read</code> falls back to <code>read</code> for all types that are not defined by us.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/RNTuple/bootstrap.jl#LL122-L144">source</a></div></details></article><article><details class="docstring" open="true"><summary id="UnROOT.@stack-Tuple{Any, Vararg{Any}}"><a class="docstring-binding" href="#UnROOT.@stack-Tuple{Any, Vararg{Any}}"><code>UnROOT.@stack</code></a> — <span class="docstring-category">Macro</span></summary><div><pre><code class="language-julia hljs">macro stack(into, structs...)</code></pre><p>Stack the fields of multiple structs and create a new one. The first argument is the name of the new struct followed by the ones to be stacked. Parametric types are not supported and the fieldnames needs to be unique.</p><p>Example:</p><pre><code class="language-julia hljs">@stack Baz Foo Bar</code></pre><p>Creates <code>Baz</code> with the concatenated fields of <code>Foo</code> and <code>Bar</code></p><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaHEP/UnROOT.jl/blob/f9ed7daf069fc9d398ad7b52d25bcd89017567e2/src/utils.jl#LL1-L15">source</a></div></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../devdocs/">« For Contributors</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Friday 14 November 2025 19:59">Friday 14 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
